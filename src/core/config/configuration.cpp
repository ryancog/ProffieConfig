// ProffieConfig, All-In-One GUI Proffieboard Configuration Utility
// Copyright (C) 2025 Ryan Ogurek

#include "core/config/configuration.h"

#include "core/defines.h"
#include "core/config/settings.h"
#include "core/config/propfile.h"
#include "core/utilities/misc.h"
#include "editor/editorwindow.h"
#include "editor/pages/generalpage.h"
#include "editor/pages/presetspage.h"
#include "editor/pages/propspage.h"
#include "editor/pages/bladespage.h"
#include "editor/dialogs/bladearraydlg.h"

#include <cstring>
#include <sstream>

#include <wx/filedlg.h>
#include <wx/event.h>

# define ERR(msg) \
  Misc::MessageBoxEvent* msgEvent = new Misc::MessageBoxEvent(wxID_ANY, std::string(msg) + "\n\nConfiguration not saved.", "Configuration Error", wxOK | wxCENTER | wxICON_ERROR); \
  wxQueueEvent(editor->GetEventHandler(), msgEvent); \
  return false;


bool Configuration::outputConfig(const std::string& filePath, const EditorWindow *editor) {
  editor->presetsPage->update();
  editor->bladesPage->update();
  editor->bladesPage->bladeArrayDlg->update();

  if (!runPreChecks(editor)) return false;

  std::ofstream configOutput(filePath);
  if (!configOutput.is_open()) {
    ERR("Could not open config file for output.");
  }

  configOutput <<
      "/*\n"
      "This configuration file was generated by ProffieConfig " VERSION ", created by Ryryog25.\n"
      "The tool can be found here: https://proffieconfig.kafrenetrading.com/\n"
      "ProffieConfig is an All-In-One utility for managing your Proffieboard.\n"
      "*/\n\n";

  outputConfigTop(configOutput, editor);
  outputConfigProp(configOutput, editor);
  outputConfigPresets(configOutput, editor);
  outputConfigButtons(configOutput, editor);

  configOutput.close();
  return true;
}
bool Configuration::outputConfig(const EditorWindow *editor) {
    return Configuration::outputConfig(CONFIG_DIR + std::string(editor->getOpenConfig()) + ".h", editor);
}

bool Configuration::exportConfig(EditorWindow *editor) {
  wxFileDialog configLocation(editor, "Save ProffieOS Config File", "", wxString{editor->getOpenConfig()}, "ProffieOS Configuration (*.h)|*.h", wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

  if (configLocation.ShowModal() == wxID_CANCEL) return false; // User Closed

  return Configuration::outputConfig(configLocation.GetPath().ToStdString(), editor);
}

void Configuration::outputConfigTop(std::ofstream& configOutput, const EditorWindow *editor) {
  configOutput << "#ifdef CONFIG_TOP" << std::endl;
  outputConfigTopGeneral(configOutput, editor);
  outputConfigTopPropSpecific(configOutput, editor);
  outputConfigTopCustom(configOutput, editor);
  configOutput << "#endif" << std::endl << std::endl;

}
void Configuration::outputConfigTopGeneral(std::ofstream& configOutput, const EditorWindow *editor) {
  if (editor->generalPage->massStorage->GetValue()) configOutput << "//PROFFIECONFIG ENABLE_MASS_STORAGE" << std::endl;
  if (editor->generalPage->webUSB->GetValue()) configOutput << "//PROFFIECONFIG ENABLE_WEBUSB" << std::endl;

  configOutput << findInVMap(Proffieboard, editor->generalPage->board->entry()->GetStringSelection().ToStdString()).second << std::endl;

  configOutput << "const unsigned int maxLedsPerStrip = " << editor->generalPage->maxLEDs->entry()->GetValue() << ";" << std::endl;
  configOutput << "#define ENABLE_AUDIO" << std::endl;
  configOutput << "#define ENABLE_WS2811" << std::endl;
  configOutput << "#define ENABLE_SD" << std::endl;
  configOutput << "#define ENABLE_MOTION" << std::endl;
  configOutput << "#define SHARED_POWER_PINS" << std::endl;

  for (const auto& [ name, define ] : editor->settings->generalDefines) {
    if (define->shouldOutput()) configOutput << "#define " << define->getOutput() << std::endl;
  }
}
void Configuration::outputConfigTopPropSpecific(std::ofstream& configOutput, const EditorWindow *editor) {
  auto selectedProp = editor->propsPage->getSelectedProp();
  if (selectedProp == nullptr) return;

  for (const auto& [ name, setting ] : *selectedProp->getSettings()) {
    if (
        !setting.checkRequiredSatisfied(*selectedProp->getSettings()) ||
        setting.disabled ||
        !setting.shouldOutput
        ) continue;

    auto output = setting.getOutput();
    if (!output.empty()) configOutput << "#define " << output << std::endl;
  }
}
void Configuration::outputConfigTopCustom(std::ofstream& configOutput, const EditorWindow *editor) {
    for (const auto& [ name, value ] : editor->generalPage->customOptDlg->getCustomDefines()) {
        if (!name.empty()) configOutput << "#define " << name << " " << value << std::endl;
    }
}

void Configuration::outputConfigProp(std::ofstream& configOutput, const EditorWindow *editor) {
  auto selectedProp = editor->propsPage->getSelectedProp();
  if (selectedProp == nullptr) return;

  configOutput << "#ifdef CONFIG_PROP" << std::endl;
  configOutput << "#include \"../props/" << selectedProp->getFileName() << "\"" << std::endl;
  configOutput << "#endif" << std:: endl << std::endl; // CONFIG_PROP
}
void Configuration::outputConfigPresets(std::ofstream& configOutput, const EditorWindow *editor) {
  configOutput << "#ifdef CONFIG_PRESETS" << std::endl;
  outputConfigPresetsStyles(configOutput, editor);
  outputConfigPresetsBlades(configOutput, editor);
  configOutput << "#endif" << std::endl << std::endl;
}

void Configuration::outputConfigPresetsStyles(std::ofstream& configOutput, const EditorWindow *editor) {
    for (const BladeArrayDlg::BladeArray& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
        configOutput << "Preset " << bladeArray.name << "[] = {\n";
        for (const PresetsPage::PresetConfig& preset : bladeArray.presets) {
            configOutput << "\t{ \"" << preset.dirs << "\", \"" << preset.track << "\",\n";
            if (preset.styles.size() > 0) {
                for (const auto& style : preset.styles) {
                    std::string line;
                    std::istringstream commentStream(style.comment.ToStdString());

                    if (not style.comment.empty()) {
                        configOutput << "\t\t/*\n";
                    }
                    while (!false) {
                        std::getline(commentStream, line);
                        configOutput << "\t\t * " << line << '\n';
                        if (commentStream.eof()) break;
                    }
                    if (not style.comment.empty()) {
                        configOutput << "\t\t */\n";
                    }

                    std::istringstream styleStream(style.style.ToStdString());
                    while (!false) {
                        std::getline(styleStream, line);
                        configOutput << "\t\t" << line;
                        if (styleStream.eof()) {
                            configOutput << ",\n";
                            break;
                        } else configOutput << '\n';
                    }
                }
            } else configOutput << "\t\t,\n";

            configOutput << "\t\t\"" << preset.name << "\"\n\t}";
            // If not the last one, add comma
            if (&bladeArray.presets[bladeArray.presets.size() - 1] != &preset) configOutput << ",";
            configOutput << '\n';
        }
        configOutput << "};\n";
    }
}

void Configuration::outputConfigPresetsBlades(std::ofstream& configOutput, const EditorWindow *editor) {
    configOutput << "BladeConfig blades[] = {" << std::endl;
    for (const BladeArrayDlg::BladeArray& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
        configOutput << "\t{ " << (bladeArray.name == "no_blade" ? "NO_BLADE" : std::to_string(bladeArray.value)) << "," << std::endl;
        for (const BladesPage::BladeConfig& blade : bladeArray.blades) {
            if (blade.type == BD_PIXELRGB || blade.type == BD_PIXELRGBW) {
                if (blade.isSubBlade) genSubBlades(configOutput, blade);
                else {
                    configOutput << "\t\t";
                    genWS281X(configOutput, blade);
                    configOutput << "," << std::endl;
                }
            } else if (blade.type == BD_SIMPLE) {
                std::array<bool, 4> powerPinUsed;
                configOutput << "\t\tSimpleBladePtr<";

                auto outputLED{[&configOutput](BladesPage::LED ledSel, int32_t resistance) {
                    wxString str{"PROFFIECONFIG_GEN_ERROR"};
                    for (const auto& [ led, ledStr ] : BladesPage::LED_CONFIGSTRS) {
                        if (ledSel == led) {
                            str = ledStr;
                            break;
                        }
                    }

                    configOutput << str;
                    auto usesResistance{ledSel & BladesPage::USES_RESISTANCE};
                    if (usesResistance) {
                        configOutput << '<' << resistance << ">, ";
                    } else configOutput << ", ";
                }};

                outputLED(blade.Star1, blade.Star1Resistance);
                powerPinUsed[0] = blade.Star1 != BladesPage::NONE;
                outputLED(blade.Star2, blade.Star2Resistance);
                powerPinUsed[1] = blade.Star2 != BladesPage::NONE;
                outputLED(blade.Star3, blade.Star3Resistance);
                powerPinUsed[2] = blade.Star3 != BladesPage::NONE;
                outputLED(blade.Star4, blade.Star4Resistance);
                powerPinUsed[3] = blade.Star4 != BladesPage::NONE;

                int8_t usageIndex = 0;
                for (auto& usePowerPin : powerPinUsed) {
                    if (usePowerPin && usageIndex < static_cast<int8_t>(blade.powerPins.size())) {
                        configOutput << blade.powerPins.at(usageIndex++);
                    } else {
                        configOutput << "-1";
                    }

                    if (&usePowerPin != &powerPinUsed[3]) configOutput << ", ";
                }
                configOutput << ">()," << std::endl;
            }
        }
        configOutput << "\t\tCONFIGARRAY(" << bladeArray.name << "), \"" << bladeArray.name << "\"" << std::endl << "\t}";
        if (&bladeArray != &editor->bladesPage->bladeArrayDlg->bladeArrays[editor->bladesPage->bladeArrayDlg->bladeArrays.size() - 1]) configOutput << ",";
        configOutput << std::endl;
    }
    configOutput << "};" << std::endl;
}

void Configuration::genWS281X(std::ofstream& configOutput, const BladesPage::BladeConfig& blade) {
  wxString bladePin = blade.dataPin;
  wxString bladeColor = blade.type == BD_PIXELRGB || blade.useRGBWithWhite ? blade.colorType : [=](wxString colorType) -> wxString { colorType.replace(colorType.find("W"), 1, "w"); return colorType; }(blade.colorType);

  configOutput << "WS281XBladePtr<" << blade.numPixels << ", " << bladePin << ", Color8::" << bladeColor << ", PowerPINS<";
  for (const auto& powerPin : blade.powerPins) {
    configOutput << powerPin << (&powerPin != &blade.powerPins.back() ? ", " : "");
  }
  configOutput << ">>()";
};
void Configuration::genSubBlades(std::ofstream& configOutput, const BladesPage::BladeConfig& blade) {
  int32_t subNum{0};
  for (const auto& subBlade : blade.subBlades) {
    if (blade.useStride) {
      configOutput << "\t\tSubBladeWithStride( ";
      configOutput << subNum << ", ";
      configOutput << blade.numPixels - blade.subBlades.size() + subNum << ", ";
      configOutput << blade.subBlades.size() << ", ";
    } else if (blade.useZigZag) {
      configOutput << "\t\tSubBladeZZ( ";
      configOutput << "0, ";
      configOutput << blade.numPixels - 1 << ", ";
      configOutput << blade.subBlades.size() << ", ";
      configOutput << subNum << ", ";
    } else {
      configOutput << "\t\tSubBlade( ";
      configOutput << subBlade.startPixel << ", " << subBlade.endPixel << ", ";
    }

    if (subNum == 0) {
      genWS281X(configOutput, blade);
      configOutput << ")," << std::endl;
    } else {
      configOutput << "NULL)," << std::endl;
    }

    subNum++;
  }
}
void Configuration::outputConfigButtons(std::ofstream& configOutput, const EditorWindow *editor) {
  configOutput << "#ifdef CONFIG_BUTTONS" << std::endl;
  configOutput << "Button PowerButton(BUTTON_POWER, powerButtonPin, \"pow\");" << std::endl;
  if (editor->generalPage->buttons->entry()->GetValue() >= 2) configOutput << "Button AuxButton(BUTTON_AUX, auxPin, \"aux\");" << std::endl;
  if (editor->generalPage->buttons->entry()->GetValue() == 3) configOutput << "Button Aux2Button(BUTTON_AUX2, aux2Pin, \"aux\");" << std::endl; // figure out aux2 syntax
  configOutput << "#endif" << std::endl << std::endl; // CONFIG_BUTTONS
}

bool Configuration::readConfig(const std::string& filePath, EditorWindow* editor) {
  std::ifstream file(filePath);
  if (!file.is_open()) return false;

  try {
    std::string section;
    while (!file.eof()) {
      file >> section;
      if (section == "//") {
        getline(file, section);
        continue;
      }
      if (std::strstr(section.data(), "/*")) {
        while (!file.eof()) {
          if (std::strstr(section.data(), "*/")) break;
          file >> section;
        }
        continue;
      }
      if (section == "#ifdef") {
        file >> section;
        if (section == "CONFIG_TOP") Configuration::readConfigTop(file, editor);
        if (section == "CONFIG_PROP") Configuration::readConfigProp(file, editor);
        if (section == "CONFIG_PRESETS") Configuration::readConfigPresets(file, editor);
        if (section == "CONFIG_STYLES") Configuration::readConfigStyles(file, editor);
      }
    }
    // Wait to call remaining defines "custom" until prop file stuffage has been read
    setCustomDefines(editor);

  } catch (std::exception& e) {
    std::string errorMessage = "There was an error parsing config, please ensure it is valid:\n\n";
    errorMessage += e.what();

    std::cerr << errorMessage << std::endl;
    return false;
  }

  //GeneralPage::update();
  editor->propsPage->update();
  editor->bladesPage->update();
  editor->presetsPage->update();

  return true;
}
bool Configuration::importConfig(EditorWindow* editor) {
  wxFileDialog configLocation(editor, "Choose ProffieOS Config File", "", "", "C Header Files (*.h)|*.h", wxFD_OPEN | wxFD_FILE_MUST_EXIST);

  if (configLocation.ShowModal() == wxID_CANCEL) return false; // User Closed

  return Configuration::readConfig(configLocation.GetPath().ToStdString(), editor);
}

void Configuration::readConfigTop(std::ifstream& file, EditorWindow* editor) {
    std::string element;
    editor->settings->readDefines.clear();
    while (!file.eof() && element != "#endif") {
        file >> element;
        if (element == "//") {
            getline(file, element);
            continue;
        }
        if (std::strstr(element.data(), "/*")) {
            while (!file.eof()) {
                if (std::strstr(element.data(), "*/")) break;
                file >> element;
            }
            continue;
        }
        if (element == "#define" && !file.eof()) {
            getline(file, element);
            editor->settings->readDefines.push_back(element);
        } else if (element == "const" && !file.eof()) {
            getline(file, element);
            std::strtok(element.data(), "="); // unsigned int maxLedsPerStrip =
            element = std::strtok(nullptr, " ;");
            editor->generalPage->maxLEDs->entry()->SetValue(std::stoi(element));
        } else if (element == "#include" && !file.eof()) {
            file >> element;
            if (element.find("v1") != std::string::npos) {
                editor->generalPage->board->entry()->SetSelection(0);
            } else if (element.find("v2") != std::string::npos) {
                editor->generalPage->board->entry()->SetSelection(1);
            } else if (element.find("v3") != std::string::npos) {
                editor->generalPage->board->entry()->SetSelection(2);
            }
        } else if (element == "//PROFFIECONFIG") {
            file >> element;
            if (element == "ENABLE_MASS_STORAGE") editor->generalPage->massStorage->SetValue(true);
            if (element == "ENABLE_WEBUSB") editor->generalPage->webUSB->SetValue(true);
        }
    }
    editor->settings->parseDefines(editor->settings->readDefines);
}

void Configuration::setCustomDefines(EditorWindow* editor) {
    for (const auto& define : editor->settings->readDefines) {
        auto key = Settings::ProffieDefine::parseKey(define);
        if (!key.first.empty()) editor->generalPage->customOptDlg->addDefine(key.first, key.second);
    }
}

void Configuration::readConfigProp(std::ifstream& file, EditorWindow* editor) {
  std::string element;
  while (!file.eof() && element != "#endif") {
    file >> element;
    for (auto& prop : editor->propsPage->getLoadedProps()) {
      auto propSettings = prop->getSettings();
      if (element.find(prop->getFileName()) != std::string::npos) {
        editor->propsPage->updateSelectedProp(prop->getName());
        for (auto define = editor->settings->readDefines.begin(); define < editor->settings->readDefines.end();) {
          std::istringstream defineStream(*define);
          std::string defineName{};
          double value{0};

          defineStream >> defineName;
          auto key = propSettings->find(defineName);
          if (key == propSettings->end()) {
            define++;
            continue;
          }

          if (
             key->second.type == PropFile::Setting::SettingType::TOGGLE ||
             key->second.type == PropFile::Setting::SettingType::OPTION
              ) {
            key->second.setValue(true);
          } else {
            defineStream >> value;
            key->second.setValue(value);
          }
          define = editor->settings->readDefines.erase(define);
        }
        break;
      }
    }
  }
}
void Configuration::readConfigPresets(std::ifstream& file, EditorWindow* editor) {
  editor->bladesPage->bladeArrayDlg->bladeArrays.clear();
  std::string element;
  while (!file.eof() && element != "#endif") {
    file >> element;
    if (element.find("//") == 0) {
      getline(file, element);
      continue;
    }
    if (std::strstr(element.data(), "/*")) {
      while (!file.eof()) {
        if (std::strstr(element.data(), "*/")) break;
        file >> element;
      }
      continue;
    }
    if (element == "Preset") readPresetArray(file, editor);
    if (element == "BladeConfig") readBladeArray(file, editor);
  }
}

void Configuration::readConfigStyles(std::ifstream& file, EditorWindow* editor) {
    char chr{0};
    enum {
        NONE,
        STYLE,
        STYLE_NAME,
        LINE_COMMENT,
        LONG_COMMENT,
    } reading, prevReading;

    std::string readHistory;
    std::string commentString;
    std::string styleString;
    std::string styleName;

    while (chr != '}' and not file.eof() and not file.bad()) {
        chr = file.get();

        if (chr == '\r') continue;
        if (
            chr == '/' and
            reading != LONG_COMMENT and
            reading != LINE_COMMENT
        ) {
            if (file.peek() == '*') {
                prevReading = reading;
                reading = LONG_COMMENT;
                file.get();
            } else if (file.peek() == '/') {
                prevReading = reading;
                reading = LINE_COMMENT;
                file.get();
            }
        }

        if (reading != LINE_COMMENT and reading != LONG_COMMENT) {
            if (chr == '#') {
                const auto initPos{file.tellg()};
                std::array<char, 5> checkArray;
                file.read(checkArray.data(), checkArray.size());
                if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                    return;
                }
                file.seekg(initPos);
            }
        }

        if (reading == NONE) {
            readHistory += chr;
            const auto usingPos{readHistory.rfind("using")};
            const auto equalPos{readHistory.rfind('=')};

            if (
                equalPos != std::string::npos and
                usingPos != std::string::npos and
                usingPos < equalPos
            ) {
                reading = STYLE;
                readHistory.clear();
            } else if (usingPos != std::string::npos) {
                reading = STYLE_NAME;
            }
        } else if (reading == LINE_COMMENT) {
            commentString += chr;
            if (chr == '\n')  {
                reading = prevReading;
            }
        } else if (reading == LONG_COMMENT) {
            // Deal with Fett's comments
            if (chr == '*' and file.peek() == '/') {
                commentString += '\n';
                reading = prevReading;
                continue;
            }
            commentString += chr;
        } else if (reading == STYLE) {
            if (chr == ';') {
                trimWhiteSpace(styleName);
                trimWhiteSpace(styleString);
                trimWhiteSpace(commentString);

                // How many nested for loops would you like? Cause here are all of 'em
                for (auto& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
                    for (auto& preset : bladeArray.presets) {
                        for (auto& [ comment, style ] : preset.styles) {
                            for (;;) { // Just because I can lol, another for loop
                                const auto usingStylePos{style.find(styleName)};
                                if (usingStylePos == std::string::npos) break;

                                style.erase(usingStylePos, styleName.length());
                                style.insert(usingStylePos, styleString);
                                if (comment.find(commentString) == std::string::npos) {
                                    comment += '\n';
                                    comment += commentString;
                                }
                            }
                        }
                    }
                }
                styleName.clear();
                styleString.clear();
                commentString.clear();
                reading = NONE;
            }

            styleString += chr;
        } else if (reading == STYLE_NAME) {
            if (chr == ' ') {
                if (not styleName.empty()) {
                    reading = NONE;
                }
                continue;
            }

            styleName += chr;
        }
    }
}

void Configuration::readPresetArray(std::ifstream& file, EditorWindow* editor) {
    const auto runToSection{[&]() -> bool {
        std::string data;
        char chr;
        do {
            chr = file.get();
            data += chr;
            if (
                file.eof() or
                file.bad() or
                data.rfind("#endif") != std::string::npos or
                data.rfind("};") != std::string::npos
            ) {
               return false;
            }
        } while (chr != '{');
        return true;
    }};

    editor->bladesPage->bladeArrayDlg->bladeArrays.push_back(BladeArrayDlg::BladeArray());
    BladeArrayDlg::BladeArray& bladeArray = editor->bladesPage->bladeArrayDlg->bladeArrays.at(editor->bladesPage->bladeArrayDlg->bladeArrays.size() - 1);

    std::string element{};
    file >> element;
    bladeArray.name.assign(element.substr(0, element.find_first_of("[]")));

    if (not runToSection()) return;
    auto presetIdx{static_cast<uint32_t>(-1)};
    bladeArray.presets.clear();
    while (!false) {
        if (not runToSection()) return;
        bladeArray.presets.push_back(PresetsPage::PresetConfig());
        ++presetIdx;

        char chr;
        enum {
            NONE,
            LINE_COMMENT,
            LONG_COMMENT,
            LONG_COMMENT_NEW_LINE,
            DIR,
            POST_DIR,
            TRACK,

        } reading{NONE}, prevReading{NONE};
        do {
            chr = file.get();

            if (chr == '\r') continue;
            if (
                chr == '/' and
                reading != LONG_COMMENT and
                reading != LONG_COMMENT_NEW_LINE and
                reading != LINE_COMMENT
            ) {
                if (file.peek() == '*') {
                    prevReading = reading;
                    reading = LONG_COMMENT;
                    file.get();
                } else if (file.peek() == '/') {
                    prevReading = reading;
                    reading = LINE_COMMENT;
                    file.get();
                }
            }

            if (reading == NONE or reading == POST_DIR) {
                if (chr == '#') {
                    const auto initPos{file.tellg()};
                    std::array<char, 5> checkArray;
                    file.read(checkArray.data(), checkArray.size());
                    if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                        return;
                    }
                    file.seekg(initPos);
                }

                if (chr == '"') {
                    if (reading == NONE) {
                        reading = DIR;
                    } else if (reading == POST_DIR) {
                        reading = TRACK;
                    }
                }
            } else if (reading == LINE_COMMENT) {
                if (chr == '\n')  {
                    reading = prevReading;
                }
            } else if (reading == LONG_COMMENT) {
                if (chr == '*' and file.peek() == '/') {
                    reading = prevReading;
                }
            } else if (reading == DIR) {
                if (chr == '"') {
                    trimWhiteSpace(bladeArray.presets[presetIdx].dirs);
                    reading = POST_DIR;
                    continue;
                }
                bladeArray.presets[presetIdx].dirs += chr;
            } else if (reading == TRACK) {
                if (chr == '"') {
                    trimWhiteSpace(bladeArray.presets[presetIdx].track);
                    break;
                }
                bladeArray.presets[presetIdx].track += chr;
            }
        } while (chr != '}' and not file.eof() and not file.bad());


        // Read actual styles
        for (int32_t blade = 0; blade < editor->settings->numBlades; ++blade) {
            size_t styleDepth{0};
            std::string styleString;
            std::string commentString;

            while (chr != '}' and not file.eof() and not file.bad()) {
                chr = file.get();

                if (chr == '\r') continue;
                if (
                    chr == '/' and
                    reading != LONG_COMMENT and
                    reading != LONG_COMMENT_NEW_LINE and
                    reading != LINE_COMMENT
                ) {
                    if (file.peek() == '*') {
                        prevReading = reading;
                        reading = LONG_COMMENT;
                        file.get();
                    } else if (file.peek() == '/') {
                        prevReading = reading;
                        reading = LINE_COMMENT;
                        file.get();
                    }
                    continue;
                }

                if (reading == NONE) {
                    if (chr == '#') {
                        const auto initPos{file.tellg()};
                        std::array<char, 5> checkArray;
                        file.read(checkArray.data(), checkArray.size());
                        if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                            return;
                        }
                        file.seekg(initPos);
                    } else if (chr == '<') ++styleDepth;
                    else if (chr == '>') --styleDepth;
                    else if (chr == ',' and styleDepth == 0) {
                        // Reached end of style
                        break;
                    }

                    // Do actual reading
                    styleString += chr;
                } else if (reading == LINE_COMMENT) {
                    commentString += chr;
                    if (chr == '\n')  {
                        reading = prevReading;
                    }
                } else if (reading == LONG_COMMENT) {
                    // Deal with Fett's comments
                    if (chr == '*' and file.peek() == '/') {
                        commentString += '\n';
                        reading = prevReading;
                        continue;
                    } else if (chr == '\n') {
                        reading = LONG_COMMENT_NEW_LINE;
                    }
                    commentString += chr;
                } else if (reading == LONG_COMMENT_NEW_LINE) {
                   if (chr == '*' and file.peek() == '/') {
                        commentString += '\n';
                        reading = prevReading;
                        continue;
                    }

                   if (std::isspace(chr) or chr == '*') continue;
                   commentString += chr;
                   reading = LONG_COMMENT;
                } else if (reading == TRACK) {
                    // Purge comma after track
                    if (chr == ',') {
                        reading = NONE;
                    }
                }
            }

            // Trim whitespace
            trimWhiteSpace(styleString);
            trimWhiteSpace(commentString);

            bladeArray.presets[presetIdx].styles.push_back({commentString, styleString});
        }

        // Name
        bool readingName{false};
        while ((chr = file.get()) != '}' and not file.eof() and not file.bad()) {
            if (chr == '"') {
                if (readingName) break;
                else readingName = true;
            } else {
                bladeArray.presets[presetIdx].name += chr;
            }
        }
        trimWhiteSpace(bladeArray.presets[presetIdx].name);
        if (bladeArray.presets[presetIdx].name.empty()) {
            bladeArray.presets[presetIdx].name = "noname";
        }
    }
}

void Configuration::readBladeArray(std::ifstream& file, EditorWindow* editor) {
# define CHKSECT if (file.eof() || element == "#endif" || strstr(element.data(), "};") != NULL) return
# define RUNTOSECTION element.clear(); while (element != "{") { file >> element; CHKSECT; }
  // In future get detect val and presetarray association

  BladeArrayDlg::BladeArray bladeArray;
  std::string element;
  std::string data;
  int32_t tempNumBlades;
  RUNTOSECTION;

  while (true) {
    bladeArray = {};
    RUNTOSECTION;
    file >> element;
    element = std::strtok(element.data(), " ,");
    bladeArray.value = std::strstr(element.data(), "NO_BLADE") ? 0 : std::stoi(element);
    CHKSECT;
    bladeArray.blades.clear();
    tempNumBlades = editor->settings->numBlades;
    for (int32_t bladeIdx = 0; bladeIdx < tempNumBlades; ++bladeIdx) {
        data.clear();

        do { // Gather entire blade data
            file >> element;
            CHKSECT;
            data.append(element);
        } while (std::strstr(data.data(), "),") == nullptr);

        if (std::strstr(data.data(), "SubBlade") != nullptr) {
            if (std::strstr(data.data(), "NULL") == nullptr) { // Top Level SubBlade
                bladeArray.blades.push_back(BladesPage::BladeConfig());
                if (std::strstr(data.data(), "WithStride")) bladeArray.blades[bladeIdx].useStride = true;
                if (std::strstr(data.data(), "ZZ")) bladeArray.blades[bladeIdx].useZigZag = true;
            } else { // Lesser SubBlade
                bladeIdx--;
                tempNumBlades--;
                // Switch to operating on previous blade
            }

            auto& blade{bladeArray.blades[bladeIdx]};
            blade.isSubBlade = true;
            std::strtok(data.data(), "("); // SubBlade(
            blade.subBlades.push_back({ (uint32_t)std::stoi(std::strtok(nullptr, "(,")), (uint32_t)std::stoi(std::strtok(nullptr, " (,")) });
            data = std::strtok(nullptr, ""); // Clear out mangled data from strtok, replace with rest of data ("" runs until end of what's left)
            // Rest will be handled by WS281X "if"
        }
        if (std::strstr(data.data(), "WS281XBladePtr") != nullptr) {
            if (static_cast<int32_t>(bladeArray.blades.size()) - 1 != bladeIdx) bladeArray.blades.push_back(BladesPage::BladeConfig());
            auto& blade{bladeArray.blades[bladeIdx]};
            data = std::strstr(data.data(), "WS281XBladePtr"); // Shift start to blade data, in case of SubBlade;

            std::strtok(data.data(), "<,"); // Clear WS281XBladePtr
            blade.numPixels = std::stoi(std::strtok(nullptr, "<,"));
            blade.dataPin = std::strtok(nullptr, ",");
            std::strtok(nullptr, ":"); // Clear Color8::
            element = std::strtok(nullptr, ":,"); // Set to color order;
            blade.useRGBWithWhite = strstr(element.data(), "W") != nullptr;
            blade.colorType.assign(element);

            std::strtok(nullptr, "<"); // Clear PowerPINS
            while (!false) {
                char* tempStore = std::strtok(nullptr, " ()<>,");
                if (tempStore == nullptr) break;
                blade.powerPins.emplace_back(tempStore);
            }
            continue;
        }
        if (std::strstr(data.data(), "SimpleBladePtr") != nullptr) {
            bladeArray.blades.push_back(BladesPage::BladeConfig());
            auto& blade{bladeArray.blades[bladeIdx]};
            blade.type.assign(BD_SIMPLE);

            auto setupStar{[](BladesPage::LED& star, int32_t& resistance) {
                auto *element{std::strtok(nullptr, "<, ")};
                BladesPage::LED ledSel{BladesPage::NONE};
                for (auto [ led, configStr ] : BladesPage::LED_CONFIGSTRS) {
                    if (0 == strcmp(element, configStr)) {
                        ledSel = led;
                        break;
                    }
                }
                star = ledSel;
                if (ledSel & BladesPage::USES_RESISTANCE) resistance = std::stoi(std::strtok(nullptr, "< >"));
            }};

            std::strtok(data.data(), "<"); // Clear SimpleBladePtr and setup strtok

            setupStar(blade.Star1, blade.Star1Resistance);
            setupStar(blade.Star2, blade.Star2Resistance);
            setupStar(blade.Star3, blade.Star3Resistance);
            setupStar(blade.Star4, blade.Star4Resistance);

            while (!false) {
                char* tempStore = std::strtok(nullptr, " ()<>,");
                if (tempStore == nullptr) break;
                if (0 != strcmp(tempStore, "-1")) blade.powerPins.emplace_back(tempStore);
            }
        }
    }

    data.clear();
    do {
      file >> element;
      CHKSECT;
      data.append(element);
    } while (std::strstr(data.data(), ")") == nullptr);

    int32_t nameStart = data.find("CONFIGARRAY(") + 12;
    int32_t nameEnd = data.find(")");
    bladeArray.name.assign(data.substr(nameStart, nameEnd - nameStart));

    if (bladeArray.blades.empty()) bladeArray.blades.push_back(BladesPage::BladeConfig{});

    for (BladeArrayDlg::BladeArray& array : editor->bladesPage->bladeArrayDlg->bladeArrays) {
      if (array.name == bladeArray.name) {
        array.value = bladeArray.value;
        array.blades = bladeArray.blades;

        if (array.value == 0 && array.name != "no_blade") {
          array.name = "blade_in";
        }
      }
    }

    for (const auto& blade : bladeArray.blades) {
      for (const auto& powerPin : blade.powerPins) {
        if (editor->bladesPage->powerPins->FindString(powerPin) == wxNOT_FOUND) editor->bladesPage->powerPins->Append(powerPin);
      }
    }
  }


# undef CHKSECT
# undef RUNTOSECTION
}

bool Configuration::runPreChecks(const EditorWindow *editor) {
    if (editor->bladesPage->bladeArrayDlg->enableDetect->GetValue() && editor->bladesPage->bladeArrayDlg->detectPin->entry()->GetValue() == "") {
        ERR("Blade Detect Pin cannot be empty.");
    }
    if (editor->bladesPage->bladeArrayDlg->enableID->GetValue() && editor->bladesPage->bladeArrayDlg->IDPin->entry()->GetValue() == "") {
        ERR("Blade ID Pin cannot be empty.");
    }
    if ([&]() { for (const BladeArrayDlg::BladeArray& array : editor->bladesPage->bladeArrayDlg->bladeArrays) if (array.name == "") return true; return false; }()) {
        ERR("Blade Array Name cannot be empty.");
    }
    if (editor->bladesPage->bladeArrayDlg->enableID->GetValue() && editor->bladesPage->bladeArrayDlg->mode->entry()->GetStringSelection() == BLADE_ID_MODE_BRIDGED && editor->bladesPage->bladeArrayDlg->pullupPin->entry()->GetValue() == "") {
        ERR("Pullup Pin cannot be empty.");
    }
    if (editor->bladesPage->bladeArrayDlg->enableDetect->GetValue() && editor->bladesPage->bladeArrayDlg->enableID->GetValue() && editor->bladesPage->bladeArrayDlg->IDPin->entry()->GetValue() == editor->bladesPage->bladeArrayDlg->detectPin->entry()->GetValue()) {
        ERR("Blade ID Pin and Blade Detect Pin cannot be the same.");
    }

    auto getNumBlades{[](const BladeArrayDlg::BladeArray& array) {
        int32_t numBlades = 0;
        for (const BladesPage::BladeConfig& blade : array.blades) {
            blade.isSubBlade ? numBlades += blade.subBlades.size() : numBlades++;
        }
        return numBlades;
    }};
    auto bladeArrayLengthsEqual{[&]() -> bool {
        int32_t lastNumBlades = getNumBlades(editor->bladesPage->bladeArrayDlg->bladeArrays.at(0));
        for (const BladeArrayDlg::BladeArray& array : editor->bladesPage->bladeArrayDlg->bladeArrays) {
            if (getNumBlades(array) != lastNumBlades) return false;
            lastNumBlades = getNumBlades(array);
        }
        return true;
    }};
    if (not bladeArrayLengthsEqual()) {
        ERR("All Blade Arrays must be the same length.\n\nPlease add/remove blades to make them equal");
    }

    for (auto& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
        for (uint32_t idx = 0; idx < bladeArray.blades.size(); idx++) {
            auto& blade{bladeArray.blades.at(idx)};
            if (blade.type != BD_SIMPLE) continue;

            uint32_t numBlades{0};
            if (blade.Star1 != BladesPage::NONE) numBlades++;
            if (blade.Star2 != BladesPage::NONE) numBlades++;
            if (blade.Star3 != BladesPage::NONE) numBlades++;
            if (blade.Star4 != BladesPage::NONE) numBlades++;

            if (blade.powerPins.size() != numBlades) {
                auto bladeName{"Simple blade " + std::to_string(idx) + " in array \"" + bladeArray.name.ToStdString() + '"'};
                auto numActiveLEDs{std::to_string(numBlades)};
                ERR(bladeName + " with " + numActiveLEDs + " active LEDs should have " + numActiveLEDs + " power pins selected. (Has " + std::to_string(blade.powerPins.size()) + ')');
            }
        }
        for (auto& preset : bladeArray.presets) {
            for (auto& [ comment, style ] : preset.styles) {
                if (style.empty()) continue;
                const auto errorString{"Malformed bladestyle in " + (preset.name.empty() ? "unnamed preset" : std::string("preset \"") + preset.name.ToStdString() + '"') + " in blade array \"" + bladeArray.name.ToStdString() + "\"\n\n"};

                const auto styleBegin{style.find("Style")};
                if (styleBegin == std::string::npos) {
                    if (style == "&style_pov" or style == "&style_charging") {
                        continue;
                    }

                    ERR(errorString + "Missing style beginning.");
                }

                size_t styleDepth{0};
                for (const char chr : style.substr(styleBegin + strlen("Style"))) {
                    if (chr == '<') ++styleDepth;
                    else if (chr == '>') --styleDepth;
                }
                if (styleDepth != 0) {
                    ERR(errorString + "Mismatched \"<>\"");
                }

                const auto styleEnd{style.find("()", styleBegin)};
                if (styleEnd == std::string::npos) {
                    const auto styleEndBegin{style.find("(\"", styleBegin)};
                    const auto styleEndEnd{style.find("\")", styleBegin)};
                    const auto extraQuotePos{style.find('"', styleBegin)};

                    if (styleEndEnd <= styleEndBegin or extraQuotePos != styleEndEnd) {
                        ERR(errorString + "Missing/malformed style end.");
                    }
                }
            }
        }
    }

    return true;
}

const Configuration::MapPair& Configuration::findInVMap(const Configuration::VMap& map, const std::string& search) {
  return *std::find_if(map.begin(), map.end(), [&](const MapPair& pair) { return (pair.second == search || pair.first == search); });
}
