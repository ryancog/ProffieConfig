#include "configuration.h"
// ProffieConfig, All-In-One GUI Proffieboard Configuration Utility
// Copyright (C) 2025 Ryan Ogurek

#include "utils/paths.h"
#include "../../core/config/settings.h"
#include "../../core/config/propfile.h"
#include "../../core/utilities/misc.h"
#include "../../editor/editorwindow.h"
#include "../../editor/pages/generalpage.h"
#include "../../editor/pages/presetspage.h"
#include "../../editor/pages/propspage.h"
#include "../../editor/pages/bladespage.h"
#include "../../editor/dialogs/bladearraydlg.h"

#include <cstring>
#include <sstream>

#include <wx/filedlg.h>
#include <wx/event.h>
#include <wx/msgdlg.h>

# define ERR(msg) \
    Misc::MessageBoxEvent* msgEvent = new Misc::MessageBoxEvent(wxID_ANY, std::string(msg) + "\n\nConfiguration not saved.", "Configuration Error", wxOK | wxCENTER | wxICON_ERROR); \
    wxQueueEvent(editor, msgEvent); \
    return false;

namespace Configuration {
    constexpr std::string_view INJECTION_STR{"injection/"};

    bool runPreChecks(EditorWindow *);

    void tryAddInjection(const std::string& buffer, EditorWindow *);

    void outputConfigTop(std::ofstream&, const EditorWindow *);
    void outputConfigTopGeneral(std::ofstream&, const EditorWindow *);
    void outputConfigTopCustom(std::ofstream&, const EditorWindow *);
    void outputConfigTopBladeAwareness(std::ofstream&, const EditorWindow *);
    void outputConfigTopPropSpecific(std::ofstream&, const EditorWindow *);
    void outputConfigTopSA22C(std::ofstream&, const EditorWindow *);
    void outputConfigTopFett263(std::ofstream&, const EditorWindow *);
    void outputConfigTopBC(std::ofstream&, const EditorWindow *);
    void outputConfigTopCaiwyn(std::ofstream&, const EditorWindow *);
    void outputConfigProp(std::ofstream&, const EditorWindow *);
    void outputConfigPresets(std::ofstream&, const EditorWindow *);
    void outputConfigPresetsStyles(std::ofstream&, const EditorWindow *);
    void outputConfigPresetsBlades(std::ofstream&, const EditorWindow *);
    void genWS281X(std::ofstream&, const BladesPage::BladeConfig&);
    void genSubBlades(std::ofstream&, const BladesPage::BladeConfig&);
    void outputConfigButtons(std::ofstream&, const EditorWindow *);

    void readConfigTop(std::ifstream&, EditorWindow*);
    void readConfigProp(std::ifstream&, EditorWindow*);
    void readConfigPresets(std::ifstream&, EditorWindow*);
    void readConfigStyles(std::ifstream&, EditorWindow*);
    void readPresetArray(std::ifstream&, EditorWindow*);
    void readBladeArray(std::ifstream&, EditorWindow*);
    void setCustomDefines(EditorWindow* editor);
}


bool Configuration::outputConfig(const std::string& filePath, EditorWindow *editor) {
    editor->presetsPage->update();
    editor->bladesPage->update();
    editor->bladesPage->bladeArrayDlg->update();

    if (not runPreChecks(editor)) return false;

    std::ofstream configOutput(filePath);
    if (!configOutput.is_open()) {
        ERR("Could not open config file for output.");
    }

    configOutput << "/*\n";
    configOutput << "This configuration file was generated by ProffieConfig " wxSTRINGIZE(EXEC_VERSION) ", created by Ryryog25.\n";
    configOutput << "The tool can be found here: https://proffieconfig.kafrenetrading.com/\n";
    configOutput << "ProffieConfig is an All-In-One utility for managing your Proffieboard.\n";
    configOutput << "*/\n\n";


    outputConfigTop(configOutput, editor);
    outputConfigProp(configOutput, editor);
    outputConfigPresets(configOutput, editor);
    outputConfigButtons(configOutput, editor);

    configOutput.close();
    return true;
}
bool Configuration::outputConfig(EditorWindow *editor) {
    return Configuration::outputConfig(Paths::configs() / (std::string(editor->getOpenConfig()) + ".h"), editor);
}

bool Configuration::exportConfig(EditorWindow *editor) {
    wxFileDialog configLocation(editor, "Save ProffieOS Config File", "", wxString{editor->getOpenConfig()}, "ProffieOS Configuration (*.h)|*.h", wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

    if (configLocation.ShowModal() == wxID_CANCEL) return false; // User Closed

    return Configuration::outputConfig(configLocation.GetPath().ToStdString(), editor);
}

void Configuration::outputConfigTop(std::ofstream& configOutput, const EditorWindow *editor) {
    configOutput << "#ifdef CONFIG_TOP" << std::endl;
    outputConfigTopGeneral(configOutput, editor);
    outputConfigTopPropSpecific(configOutput, editor);
    outputConfigTopCustom(configOutput, editor);
    configOutput << "#endif" << std::endl << std::endl;

}
void Configuration::outputConfigTopGeneral(std::ofstream& configOutput, const EditorWindow *editor) {
    if (editor->generalPage->massStorage->GetValue()) configOutput << "//PROFFIECONFIG ENABLE_MASS_STORAGE" << std::endl;
    if (editor->generalPage->webUSB->GetValue()) configOutput << "//PROFFIECONFIG ENABLE_WEBUSB" << std::endl;

    configOutput << findInVMap(Proffieboard, editor->generalPage->board->entry()->GetStringSelection().ToStdString()).second << std::endl;

    configOutput << "const unsigned int maxLedsPerStrip = " << editor->generalPage->maxLEDs->entry()->GetValue() << ";" << std::endl;
    configOutput << "#define ENABLE_AUDIO" << std::endl;
    configOutput << "#define ENABLE_WS2811" << std::endl;
    configOutput << "#define ENABLE_SD" << std::endl;
    configOutput << "#define ENABLE_MOTION" << std::endl;
    configOutput << "#define SHARED_POWER_PINS" << std::endl;

    for (const auto& [ name, define ] : editor->settings->generalDefines) {
        if (define->shouldOutput()) configOutput << "#define " << define->getOutput() << std::endl;
    }
}
void Configuration::outputConfigTopPropSpecific(std::ofstream& configOutput, const EditorWindow *editor) {
    auto selectedProp = editor->propsPage->getSelectedProp();
    if (selectedProp == nullptr) return;

    for (const auto& [ name, setting ] : *selectedProp->getSettings()) {
        if (
                        !setting.checkRequiredSatisfied(*selectedProp->getSettings()) ||
                        setting.disabled ||
                        !setting.shouldOutput
                        ) continue;

        auto output = setting.getOutput();
        if (!output.empty()) configOutput << "#define " << output << std::endl;
    }
}
void Configuration::outputConfigTopCustom(std::ofstream& configOutput, const EditorWindow *editor) {
    for (const auto& [ name, value ] : editor->generalPage->customOptDlg->getCustomDefines()) {
        if (!name.empty()) configOutput << "#define " << name << " " << value << std::endl;
    }
}

void Configuration::outputConfigProp(std::ofstream& configOutput, const EditorWindow *editor) {
    auto selectedProp = editor->propsPage->getSelectedProp();
    if (selectedProp == nullptr) return;

    configOutput << "#ifdef CONFIG_PROP" << std::endl;
    configOutput << "#include \"../props/" << selectedProp->getFileName() << "\"" << std::endl;
    configOutput << "#endif" << std:: endl << std::endl; // CONFIG_PROP
}
void Configuration::outputConfigPresets(std::ofstream& configOutput, const EditorWindow *editor) {
    configOutput << "#ifdef CONFIG_PRESETS\n" << std::flush;
    for (const auto& injection : editor->presetsPage->injections) {
        configOutput << "#include \"" << INJECTION_STR << injection << '"' << std::endl;
    }
    if (not editor->presetsPage->injections.empty()) configOutput << std::endl;
    outputConfigPresetsStyles(configOutput, editor);
    outputConfigPresetsBlades(configOutput, editor);
    configOutput << "#endif\n\n" << std::flush;
}

void Configuration::outputConfigPresetsStyles(std::ofstream& configOutput, const EditorWindow *editor) {
    for (const BladeArrayDlg::BladeArray& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
        configOutput << "Preset " << bladeArray.name << "[] = {\n";
        for (const PresetsPage::PresetConfig& preset : bladeArray.presets) {
            configOutput << "\t{ \"" << preset.dirs << "\", \"" << preset.track << "\",\n";
            if (preset.styles.size() > 0) {
                for (const auto& style : preset.styles) {
                    std::string line;
                    std::istringstream commentStream(style.comment.ToStdString());

                    if (not style.comment.empty()) {
                        configOutput << "\t\t/*\n";
                    }
                    while (!false) {
                        std::getline(commentStream, line);
                        if (commentStream.eof()) break;
                        configOutput << "\t\t * " << line << '\n';
                    }
                    if (not style.comment.empty()) {
                        configOutput << "\t\t */\n";
                    }

                    std::istringstream styleStream(style.style.ToStdString());
                    while (!false) {
                        std::getline(styleStream, line);
                        configOutput << "\t\t" << line;
                        if (styleStream.eof()) {
                            configOutput << ",\n";
                            break;
                        } else configOutput << '\n';
                    }
                }
            } else configOutput << "\t\t,\n";

            configOutput << "\t\t\"" << preset.name << "\"\n\t}";
            // If not the last one, add comma
            if (&bladeArray.presets[bladeArray.presets.size() - 1] != &preset) configOutput << ",";
            configOutput << '\n';
        }
        configOutput << "};\n";
    }
}

void Configuration::outputConfigPresetsBlades(std::ofstream& configOutput, const EditorWindow *editor) {
    configOutput << "BladeConfig blades[] = {" << std::endl;
    for (const BladeArrayDlg::BladeArray& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
        configOutput << "\t{ " << (bladeArray.name == "no_blade" ? "NO_BLADE" : std::to_string(bladeArray.value)) << "," << std::endl;
        for (const BladesPage::BladeConfig& blade : bladeArray.blades) {
            if (blade.type == BD_PIXELRGB || blade.type == BD_PIXELRGBW) {
                if (blade.isSubBlade) genSubBlades(configOutput, blade);
                else {
                    configOutput << "\t\t";
                    genWS281X(configOutput, blade);
                    configOutput << "," << std::endl;
                }
            } else if (blade.type == BD_SIMPLE) {
                std::array<bool, 4> powerPinUsed;
                configOutput << "\t\tSimpleBladePtr<";

                auto outputLED{[&configOutput](BladesPage::LED ledSel, int32_t resistance) {
                        wxString str{"PROFFIECONFIG_GEN_ERROR"};
                        for (const auto& [ led, ledStr ] : BladesPage::LED_CONFIGSTRS) {
                            if (ledSel == led) {
                                str = ledStr;
                                break;
                            }
                        }

                        configOutput << str;
                        auto usesResistance{ledSel & BladesPage::USES_RESISTANCE};
                        if (usesResistance) {
                            configOutput << '<' << resistance << ">, ";
                        } else configOutput << ", ";
                    }};

                outputLED(blade.Star1, blade.Star1Resistance);
                powerPinUsed[0] = blade.Star1 != BladesPage::NONE;
                outputLED(blade.Star2, blade.Star2Resistance);
                powerPinUsed[1] = blade.Star2 != BladesPage::NONE;
                outputLED(blade.Star3, blade.Star3Resistance);
                powerPinUsed[2] = blade.Star3 != BladesPage::NONE;
                outputLED(blade.Star4, blade.Star4Resistance);
                powerPinUsed[3] = blade.Star4 != BladesPage::NONE;

                int8_t usageIndex = 0;
                for (auto& usePowerPin : powerPinUsed) {
                    if (usePowerPin && usageIndex < static_cast<int8_t>(blade.powerPins.size())) {
                        configOutput << blade.powerPins.at(usageIndex++);
                    } else {
                        configOutput << "-1";
                    }

                    if (&usePowerPin != &powerPinUsed[3]) configOutput << ", ";
                }
                configOutput << ">()," << std::endl;
            }
        }
        configOutput << "\t\tCONFIGARRAY(" << bladeArray.name << "), \"" << bladeArray.name << "\"" << std::endl << "\t}";
        if (&bladeArray != &editor->bladesPage->bladeArrayDlg->bladeArrays[editor->bladesPage->bladeArrayDlg->bladeArrays.size() - 1]) configOutput << ",";
        configOutput << std::endl;
    }
    configOutput << "};" << std::endl;
}

void Configuration::genWS281X(std::ofstream& configOutput, const BladesPage::BladeConfig& blade) {
    wxString bladePin = blade.dataPin;
    wxString bladeColor = blade.type == BD_PIXELRGB || blade.useRGBWithWhite ? blade.colorType : [=](wxString colorType) -> wxString { colorType.replace(colorType.find("W"), 1, "w"); return colorType; }(blade.colorType);

    configOutput << "WS281XBladePtr<" << blade.numPixels << ", " << bladePin << ", Color8::" << bladeColor << ", PowerPINS<";
    for (const auto& powerPin : blade.powerPins) {
        configOutput << powerPin << (&powerPin != &blade.powerPins.back() ? ", " : "");
    }
    configOutput << ">>()";
};
void Configuration::genSubBlades(std::ofstream& configOutput, const BladesPage::BladeConfig& blade) {
    int32_t subNum{0};
    for (const auto& subBlade : blade.subBlades) {
        if (blade.useStride) {
            configOutput << "\t\tSubBladeWithStride( ";
            configOutput << subNum << ", ";
            configOutput << blade.numPixels - blade.subBlades.size() + subNum << ", ";
            configOutput << blade.subBlades.size() << ", ";
        } else if (blade.useZigZag) {
            configOutput << "\t\tSubBladeZZ( ";
            configOutput << "0, ";
            configOutput << blade.numPixels - 1 << ", ";
            configOutput << blade.subBlades.size() << ", ";
            configOutput << subNum << ", ";
        } else {
            configOutput << "\t\tSubBlade( ";
            configOutput << subBlade.startPixel << ", " << subBlade.endPixel << ", ";
        }

        if (subNum == 0) {
            genWS281X(configOutput, blade);
            configOutput << ")," << std::endl;
        } else {
            configOutput << "NULL)," << std::endl;
        }

        subNum++;
    }
}
void Configuration::outputConfigButtons(std::ofstream& configOutput, const EditorWindow *editor) {
    configOutput << "#ifdef CONFIG_BUTTONS" << std::endl;
    configOutput << "Button PowerButton(BUTTON_POWER, powerButtonPin, \"pow\");" << std::endl;
    if (editor->generalPage->buttons->entry()->GetValue() >= 2) configOutput << "Button AuxButton(BUTTON_AUX, auxPin, \"aux\");" << std::endl;
    if (editor->generalPage->buttons->entry()->GetValue() == 3) configOutput << "Button Aux2Button(BUTTON_AUX2, aux2Pin, \"aux\");" << std::endl; // figure out aux2 syntax
    configOutput << "#endif" << std::endl << std::endl; // CONFIG_BUTTONS
}

bool Configuration::readConfig(const std::string& filePath, EditorWindow* editor) {
    std::ifstream file(filePath);
    if (!file.is_open()) return false;

    try {
        std::string buffer;
        while (!file.eof()) {
            file >> buffer;
            if (buffer == "//") {
                getline(file, buffer);
                continue;
            }
            if (std::strstr(buffer.data(), "/*")) {
                while (!file.eof()) {
                    if (std::strstr(buffer.data(), "*/")) break;
                    file >> buffer;
                }
                continue;
            }
            if (buffer == "#ifdef") {
                file >> buffer;
                if (buffer == "CONFIG_TOP") Configuration::readConfigTop(file, editor);
                if (buffer == "CONFIG_PROP") Configuration::readConfigProp(file, editor);
                if (buffer == "CONFIG_PRESETS") Configuration::readConfigPresets(file, editor);
                if (buffer == "CONFIG_STYLES") Configuration::readConfigStyles(file, editor);
            }
            if (buffer == "#include") {
                getline(file, buffer);
                tryAddInjection(buffer, editor);
            }
        }
        // Wait to call remaining defines "custom" until prop file stuffage has been read
        setCustomDefines(editor);

    } catch (std::exception& e) {
        std::string errorMessage = "There was an error parsing config, please ensure it is valid:\n\n";
        errorMessage += e.what();

        std::cerr << errorMessage << std::endl;
        return false;
    }

    //GeneralPage::update();
    editor->propsPage->update();
    editor->bladesPage->update();
    editor->presetsPage->update();

    return true;
}

void Configuration::tryAddInjection(const std::string& buffer, EditorWindow *editor) {
    auto strStart{buffer.find('"')};
    if (strStart == std::string::npos) return;
    auto strEnd{buffer.find('"', strStart + 1)};
    if (strEnd == std::string::npos) return;

    auto injectionPos{buffer.find(INJECTION_STR, strStart + 1)};
    std::string injectionFile;
    if (injectionPos != std::string::npos) {
        injectionFile = buffer.substr(injectionPos + INJECTION_STR.length(), strEnd - injectionPos - INJECTION_STR.length());
    } else {
        injectionFile = buffer.substr(strStart + 1, strEnd - strStart - 1);
    }

    std::string filePath{Paths::injections() / injectionFile};
    std::error_code err;
    if (not fs::exists(filePath, err)) {
        if (wxYES != wxMessageBox("Injection file \"" + injectionFile + "\" has not been registered.\nWould you like to add the injection file now?", "Unknown Injection Encountered", wxYES_NO | wxYES_DEFAULT)) {
            return;
        }

        while (not false) {
            wxFileDialog fileDialog{
                nullptr,
                "Choose injection file for \"" + injectionFile + '"',
                wxEmptyString,
                wxEmptyString,
                "C Header (*.h)|*.h",
                wxFD_OPEN | wxFD_FILE_MUST_EXIST
            };
            if (fileDialog.ShowModal() == wxID_CANCEL) return;

            std::string copyPath{Paths::injections() / fileDialog.GetFilename().ToStdString()};
            const auto copyOptions{fs::copy_options::overwrite_existing};
            if (not fs::copy_file(fileDialog.GetPath().ToStdString(), copyPath, copyOptions, err)) {
                std::cout << fileDialog.GetPath().ToStdString() << std::endl;
                auto res{wxMessageBox(err.message(), "Injection file could not be added.", wxOK | wxCANCEL | wxOK_DEFAULT)};
                if (res == wxCANCEL) return;
                else continue;
            }

            injectionFile = fileDialog.GetFilename().ToStdString();
            break;
        }
    }

    editor->presetsPage->injections.emplace_back(injectionFile);
}


bool Configuration::importConfig(EditorWindow* editor) {
    wxFileDialog configLocation(editor, "Choose ProffieOS Config File", "", "", "C Header Files (*.h)|*.h", wxFD_OPEN | wxFD_FILE_MUST_EXIST);

    if (configLocation.ShowModal() == wxID_CANCEL) return false; // User Closed

    return Configuration::readConfig(configLocation.GetPath().ToStdString(), editor);
}

void Configuration::readConfigTop(std::ifstream& file, EditorWindow* editor) {
    std::string element;
    editor->settings->readDefines.clear();
    while (!file.eof() && element != "#endif") {
        file >> element;
        if (element == "//") {
            getline(file, element);
            continue;
        }
        if (std::strstr(element.data(), "/*")) {
            while (!file.eof()) {
                if (std::strstr(element.data(), "*/")) break;
                file >> element;
            }
            continue;
        }
        if (element == "#define" && !file.eof()) {
            getline(file, element);
            editor->settings->readDefines.push_back(element);
        } else if (element == "const" && !file.eof()) {
            getline(file, element);
            std::strtok(element.data(), "="); // unsigned int maxLedsPerStrip =
            element = std::strtok(nullptr, " ;");
            editor->generalPage->maxLEDs->entry()->SetValue(std::stoi(element));
        } else if (element == "#include" && !file.eof()) {
            file >> element;
            if (element.find("v1") != std::string::npos) {
                editor->generalPage->board->entry()->SetSelection(0);
            } else if (element.find("v2") != std::string::npos) {
                editor->generalPage->board->entry()->SetSelection(1);
            } else if (element.find("v3") != std::string::npos) {
                editor->generalPage->board->entry()->SetSelection(2);
            }
        } else if (element == "//PROFFIECONFIG") {
            file >> element;
            if (element == "ENABLE_MASS_STORAGE") editor->generalPage->massStorage->SetValue(true);
            if (element == "ENABLE_WEBUSB") editor->generalPage->webUSB->SetValue(true);
        }
    }
    editor->settings->parseDefines(editor->settings->readDefines);
}

void Configuration::setCustomDefines(EditorWindow* editor) {
    for (const auto& define : editor->settings->readDefines) {
        auto key = Settings::ProffieDefine::parseKey(define);
        if (!key.first.empty()) editor->generalPage->customOptDlg->addDefine(key.first, key.second);
    }
}

void Configuration::readConfigProp(std::ifstream& file, EditorWindow* editor) {
    std::string element;
    while (!file.eof() && element != "#endif") {
        file >> element;
        for (auto& prop : editor->propsPage->getLoadedProps()) {
            auto propSettings = prop->getSettings();
            if (element.find(prop->getFileName()) != std::string::npos) {
                editor->propsPage->updateSelectedProp(prop->getName());
                for (auto define = editor->settings->readDefines.begin(); define < editor->settings->readDefines.end();) {
                    std::istringstream defineStream(*define);
                    std::string defineName{};
                    double value{0};

                    defineStream >> defineName;
                    auto key = propSettings->find(defineName);
                    if (key == propSettings->end()) {
                        define++;
                        continue;
                    }

                    if (
                                    key->second.type == PropFile::Setting::SettingType::TOGGLE ||
                                    key->second.type == PropFile::Setting::SettingType::OPTION
                                    ) {
                        key->second.setValue(true);
                    } else {
                        defineStream >> value;
                        key->second.setValue(value);
                    }
                    define = editor->settings->readDefines.erase(define);
                }
                break;
            }
        }
    }
}
void Configuration::readConfigPresets(std::ifstream& file, EditorWindow* editor) {
    editor->bladesPage->bladeArrayDlg->bladeArrays.clear();
    std::string element;
    while (!file.eof() && element != "#endif") {
        file >> element;
        if (element.find("//") == 0) {
            getline(file, element);
            continue;
        }
        if (std::strstr(element.data(), "/*")) {
            while (!file.eof()) {
                if (std::strstr(element.data(), "*/")) break;
                file >> element;
            }
            continue;
        }
        if (element == "Preset") readPresetArray(file, editor);
        if (element == "BladeConfig") readBladeArray(file, editor);
        if (element == "#include") {
            getline(file, element);
            tryAddInjection(element, editor);
        }
    }
}

void Configuration::readConfigStyles(std::ifstream& file, EditorWindow* editor) {
    char chr{0};
    enum {
        NONE,
        STYLE,
        STYLE_NAME,
        LINE_COMMENT,
        LONG_COMMENT,
    } reading{NONE}, prevReading{NONE};

    std::string readHistory;
    std::string commentString;
    std::string styleString;
    std::string styleName;

    while (chr != '}' and not file.eof() and not file.bad()) {
        chr = file.get();

        if (chr == '\r') continue;
        if (
                        chr == '/' and
                        reading != LONG_COMMENT and
                        reading != LINE_COMMENT
                        ) {
            if (file.peek() == '*') {
                prevReading = reading;
                reading = LONG_COMMENT;
                file.get();
                continue;
            } else if (file.peek() == '/') {
                prevReading = reading;
                reading = LINE_COMMENT;
                file.get();
                continue;
            }
        }

        if (reading != LINE_COMMENT and reading != LONG_COMMENT) {
            if (chr == '#') {
                const auto initPos{file.tellg()};
                std::array<char, 5> checkArray;
                file.read(checkArray.data(), checkArray.size());
                if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                    return;
                }
                file.seekg(initPos);
            }
        }

        if (reading == NONE) {
            readHistory += chr;
            const auto usingPos{readHistory.rfind("using")};
            const auto equalPos{readHistory.rfind('=')};

            if (
                            equalPos != std::string::npos and
                            usingPos != std::string::npos and
                            usingPos < equalPos
                            ) {
                reading = STYLE;
                readHistory.clear();
            } else if (usingPos != std::string::npos) {
                reading = STYLE_NAME;
            }
        } else if (reading == LINE_COMMENT) {
            commentString += chr;
            if (chr == '\n')  {
                reading = prevReading;
            }
        } else if (reading == LONG_COMMENT) {
            // Deal with Fett's comments
            if (chr == '*' and file.peek() == '/') {
                commentString += '\n';
                reading = prevReading;
                file.get();
                continue;
            }
            commentString += chr;
        } else if (reading == STYLE) {
            if (chr == ';') {
                trimWhiteSpace(styleName);
                trimWhiteSpace(styleString);
                trimWhiteSpace(commentString);

                // How many nested for loops would you like? Cause here are all of 'em
                for (auto& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
                    for (auto& preset : bladeArray.presets) {
                        for (auto& [ comment, style ] : preset.styles) {
                            for (;;) { // Just because I can lol, another for loop
                                const auto usingStylePos{style.find(styleName)};
                                if (usingStylePos == std::string::npos) break;

                                style.erase(usingStylePos, styleName.length());
                                style.insert(usingStylePos, styleString);
                                if (comment.find(commentString) == std::string::npos) {
                                    comment += '\n';
                                    comment += commentString;
                                }
                            }
                        }
                    }
                }
                styleName.clear();
                styleString.clear();
                commentString.clear();
                reading = NONE;
                continue;
            }

            styleString += chr;
        } else if (reading == STYLE_NAME) {
            if (chr == ' ') {
                if (not styleName.empty()) {
                    reading = NONE;
                }
                continue;
            }

            styleName += chr;
        }
    }
}

void Configuration::readPresetArray(std::ifstream& file, EditorWindow* editor) {
    editor->bladesPage->bladeArrayDlg->bladeArrays.push_back(BladeArrayDlg::BladeArray());
    BladeArrayDlg::BladeArray& bladeArray = editor->bladesPage->bladeArrayDlg->bladeArrays.at(editor->bladesPage->bladeArrayDlg->bladeArrays.size() - 1);

    std::string element{};
    file >> element;
    bladeArray.name.assign(element.substr(0, element.find_first_of("[]")));

    char chr;
    element.clear();
    do {
        chr = file.get();
        element += chr;
        if (
                        file.eof() or
                        file.bad() or
                        element.rfind("#endif") != std::string::npos or
                        element.rfind("};") != std::string::npos
                        ) {
            return;
        }
    } while (chr != '{');

    auto presetIdx{static_cast<uint32_t>(-1)};
    bladeArray.presets.clear();
    while (!false) {
        bladeArray.presets.emplace_back();
        ++presetIdx;

        enum {
            NONE,
            LINE_COMMENT,
            LONG_COMMENT,
            LONG_COMMENT_NEW_LINE,
            POST_BRACE,
            DIR,
            POST_DIR,
            TRACK,

            NAME,
            PRUNE,
        } reading{NONE}, prevReading{NONE};
        while (not file.eof() and not file.bad()) {
            chr = file.get();

            if (chr == '\r') continue;
            if (reading != LONG_COMMENT and reading != LONG_COMMENT_NEW_LINE and reading != LINE_COMMENT) {
                if (chr == '/') {
                    if (file.peek() == '*') {
                        prevReading = reading;
                        reading = LONG_COMMENT;
                        file.get();
                        continue;
                    } else if (file.peek() == '/') {
                        prevReading = reading;
                        reading = LINE_COMMENT;
                        file.get();
                        continue;
                    }
                }
                if (chr == '#') {
                    const auto initPos{file.tellg()};
                    std::array<char, 5> checkArray;
                    file.read(checkArray.data(), checkArray.size());
                    if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                        return;
                    }
                    file.seekg(initPos);
                }
                if (chr == '}') {
                    if (file.peek() == ';') {
                        bladeArray.presets.pop_back();
                        return;
                    } else {
                        break;
                    }
                }
            }

            if (reading == NONE) {
                if (chr == '{') {
                    reading = POST_BRACE;
                }
            } else if (reading == POST_BRACE or reading == POST_DIR) {
                if (chr == '"') {
                    if (reading == POST_BRACE) {
                        reading = DIR;
                    } else if (reading == POST_DIR) {
                        reading = TRACK;
                    }
                }
            } else if (reading == LINE_COMMENT) {
                if (chr == '\n')  {
                    reading = prevReading;
                }
            } else if (reading == LONG_COMMENT) {
                if (chr == '*' and file.peek() == '/') {
                    file.get();
                    reading = prevReading;
                }
            } else if (reading == DIR) {
                if (chr == '"') {
                    trimWhiteSpace(bladeArray.presets[presetIdx].dirs);
                    reading = POST_DIR;
                    continue;
                }
                bladeArray.presets[presetIdx].dirs += chr;
            } else if (reading == TRACK) {
                if (chr == '"') {
                    trimWhiteSpace(bladeArray.presets[presetIdx].track);
                    break;
                }
                bladeArray.presets[presetIdx].track += chr;
            }
        }


        // Read actual styles
        for (int32_t blade = 0; blade < editor->settings->numBlades; ++blade) {
            size_t styleDepth{0};
            std::string styleString;
            std::string commentString;

            while (not file.eof() and not file.bad()) {
                chr = file.get();

                if (chr == '\r') continue;
                if (
                                chr == '/' and
                                reading != LONG_COMMENT and
                                reading != LONG_COMMENT_NEW_LINE and
                                reading != LINE_COMMENT
                                ) {
                    if (file.peek() == '*') {
                        prevReading = reading;
                        reading = LONG_COMMENT;
                        file.get();
                        continue;
                    } else if (file.peek() == '/') {
                        prevReading = reading;
                        reading = LINE_COMMENT;
                        file.get();
                        continue;
                    }
                }
                if (chr == '#') {
                    const auto initPos{file.tellg()};
                    std::array<char, 5> checkArray;
                    file.read(checkArray.data(), checkArray.size());
                    if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                        return;
                    }
                    file.seekg(initPos);
                }
                if (chr == '}') {
                    if (file.peek() == ';') {
                        bladeArray.presets.pop_back();
                        return;
                    } else {
                        break;
                    }
                }

                if (reading == NONE) {
                    if (chr == '<') ++styleDepth;
                    else if (chr == '>') --styleDepth;
                    else if (chr == ',' and styleDepth == 0) {
                        // Reached end of style
                        break;
                    }

                    // Do actual reading
                    styleString += chr;
                } else if (reading == LINE_COMMENT) {
                    commentString += chr;
                    if (chr == '\n')  {
                        reading = prevReading;
                    }
                } else if (reading == LONG_COMMENT) {
                    // Deal with Fett's comments
                    if (chr == '*' and file.peek() == '/') {
                        commentString += '\n';
                        reading = prevReading;
                        continue;
                    } else if (chr == '\n') {
                        reading = LONG_COMMENT_NEW_LINE;
                    }
                    commentString += chr;
                } else if (reading == LONG_COMMENT_NEW_LINE) {
                    if (chr == '*' and file.peek() == '/') {
                        commentString += '\n';
                        reading = prevReading;
                        file.get();
                        continue;
                    }

                    if (std::isspace(chr) or chr == '*') continue;
                    commentString += chr;
                    reading = LONG_COMMENT;
                } else if (reading == TRACK) {
                    // Purge comma after track
                    if (chr == ',') {
                        reading = NONE;
                    }
                }
            }

            // Trim whitespace
            trimWhiteSpace(styleString);
            trimWhiteSpace(commentString);

            bladeArray.presets[presetIdx].styles.push_back({commentString, styleString});
        }

        if (chr != '}') {
            reading = NONE;
            while (not file.eof() and not file.bad()) {
                chr = file.get();

                if (chr == '\r') continue;
                if (
                        chr == '/' and
                        reading != LONG_COMMENT and
                        reading != LONG_COMMENT_NEW_LINE and
                        reading != LINE_COMMENT
                        ) {
                    if (file.peek() == '*') {
                        prevReading = reading;
                        reading = LONG_COMMENT;
                        file.get();
                        continue;
                    } else if (file.peek() == '/') {
                        prevReading = reading;
                        reading = LINE_COMMENT;
                        file.get();
                        continue;
                    }
                }
                if (chr == '#') {
                    const auto initPos{file.tellg()};
                    std::array<char, 5> checkArray;
                    file.read(checkArray.data(), checkArray.size());
                    if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                        return;
                    }
                    file.seekg(initPos);
                }
                if (chr == '}') {
                    if (file.peek() == ';') {
                        bladeArray.presets.pop_back();
                        return;
                    } else {
                        break;
                    }
                }

                if (reading == NONE) {
                    if (chr == '"') {
                        reading = NAME;
                    }
                } else if (reading == LINE_COMMENT) {
                    if (chr == '\n')  {
                        reading = prevReading;
                    }
                } else if (reading == LONG_COMMENT) {
                    if (chr == '*' and file.peek() == '/') {
                        reading = prevReading;
                        file.get();
                    }
                } else if (reading == NAME) {
                    if (chr == '"') {
                        trimWhiteSpace(bladeArray.presets[presetIdx].name);
                        reading = PRUNE;
                        continue;
                    }
                    bladeArray.presets[presetIdx].name += chr;
                }
            }
        }

        trimWhiteSpace(bladeArray.presets[presetIdx].name);
        if (bladeArray.presets[presetIdx].name.empty()) {
            bladeArray.presets[presetIdx].name = "noname";
        }
    }
}

void Configuration::readBladeArray(std::ifstream& file, EditorWindow* editor) {
    enum {
        NONE,
        LINE_COMMENT,
        LONG_COMMENT,
        LONG_COMMENT_NEW_LINE,

        IN_ARRAY,
        ID_NUM,
        BLADE_ENTRY,
        CONFIG_ARRAY,
    } reading{NONE}, prevReading{NONE};
    char chr{};

    BladeArrayDlg::BladeArray bladeArray;

    std::string buffer;
    int32_t bladesRead{0};

    std::vector<char> bladeSects{};

    while (not file.eof() and not file.bad()) {
        chr = file.get();

        if (chr == '\r') continue;
        if (reading != LONG_COMMENT and reading != LONG_COMMENT_NEW_LINE and reading != LINE_COMMENT) {
            if (chr == '/') {
                if (file.peek() == '*') {
                    prevReading = reading;
                    reading = LONG_COMMENT;
                    file.get();
                    continue;
                } else if (file.peek() == '/') {
                    prevReading = reading;
                    reading = LINE_COMMENT;
                    file.get();
                    continue;
                }
            }
            if (chr == '#') {
                const auto initPos{file.tellg()};
                std::array<char, 5> checkArray;
                file.read(checkArray.data(), checkArray.size());
                if (0 == strncmp(checkArray.data(), "endif", checkArray.size())) {
                    return;
                }
                file.seekg(initPos);
            }
            if (chr == '}') {
                if (file.peek() == ';') {
                    return;
                } else {
                    reading = NONE;
                    bladeArray = {};
                    continue;
                }
            }
        }

        if (reading == LINE_COMMENT) {
            if (chr == '\n')  {
                reading = prevReading;
            }
        } else if (reading == LONG_COMMENT) {
            if (chr == '*' and file.peek() == '/') {
                file.get();
                reading = prevReading;
            }
        } else if (reading == NONE) {
            if (chr == '{') {
                reading = IN_ARRAY;
                bladeArray = {};
            }
        } else if (reading == IN_ARRAY) {
            if (chr == '{') {
                reading = ID_NUM;
            }
        } else if (reading == ID_NUM) {
            if (chr == ',') {
                trimWhiteSpace(buffer);
                bladeArray.value = buffer == "NO_BLADE" ? 0 : std::stoi(buffer);
                buffer.clear();
                reading = BLADE_ENTRY;
                continue;
            }

            buffer += chr;
        } else if (reading == BLADE_ENTRY) {
            if (
                not bladeSects.empty() and
                ((bladeSects.back() == '<' and chr == '>') or
                (bladeSects.back() == '(' and chr == ')'))
            ) {
                bladeSects.pop_back();
            } else if (chr == '<' or chr == '(') {
                bladeSects.push_back(chr);
            } else if (chr == ',' and bladeSects.empty()) {
                trimWhiteSpace(buffer);

                bool subBlade{false};
                if (buffer.find("SubBlade") == 0) {
                    if (buffer.find("NULL") != std::string::npos or buffer.find("nullptr") != std::string::npos) { // Top Level SubBlade
                        bladeArray.blades.emplace_back();
                        bladeArray.blades.back().isSubBlade = true;
                        if (buffer.find("WithStride") != std::string::npos) bladeArray.blades.back().useStride = true;
                        if (buffer.find("ZZ") != std::string::npos) bladeArray.blades.back().useZigZag = true;
                    }

                    auto& blade{bladeArray.blades.back()};
                    buffer = buffer.substr(buffer.find('(') + 1);

                    auto paramEnd{buffer.find(',')};
                    const auto num1{std::stoi(buffer.substr(0, paramEnd))};
                    buffer = buffer.substr(paramEnd + 1);

                    paramEnd = buffer.find(',');
                    const auto num2{std::stoi(buffer.substr(0, paramEnd))};
                    buffer = buffer.substr(paramEnd + 1);

                    blade.subBlades.push_back({ static_cast<uint32_t>(num1), static_cast<uint32_t>(num2) });
                    subBlade = true;
                }

                constexpr std::string_view ws281xStr{"WS281XBladePtr"};
                constexpr std::string_view simpleStr{"SimpleBladePtr"};
                if (buffer.find(ws281xStr) != std::string::npos) {
                    if (not subBlade) bladeArray.blades.emplace_back();
                    auto& blade{bladeArray.blades.back()};

                    buffer = buffer.substr(buffer.find(ws281xStr) + ws281xStr.length());
                    buffer = buffer.substr(buffer.find('<') + 1);

                    auto paramEnd{buffer.find(',')};
                    blade.numPixels = std::stoi(buffer.substr(0, paramEnd));
                    buffer = buffer.substr(paramEnd + 1);

                    paramEnd = buffer.find(',');
                    auto dataPinStr{buffer.substr(0, paramEnd)};
                    trimWhiteSpace(dataPinStr);
                    blade.dataPin = dataPinStr;
                    buffer = buffer.substr(paramEnd + 1);

                    constexpr std::string_view color8{"Color8"};
                    constexpr std::string_view namespaceSeparator{"::"};
                    buffer = buffer.substr(buffer.find(color8) + color8.length());
                    buffer = buffer.substr(buffer.find(namespaceSeparator) + namespaceSeparator.length());

                    paramEnd = buffer.find(',');
                    auto colorStr{buffer.substr(0, paramEnd)};
                    trimWhiteSpace(colorStr);

                    blade.useRGBWithWhite = colorStr.find('W') != std::string::npos;
                    blade.type = (blade.useRGBWithWhite or colorStr.find('w') != std::string::npos) ? BD_PIXELRGBW : BD_PIXELRGB;
                    blade.colorType.assign(colorStr);

                    constexpr std::string_view powerPins{"PowerPINS"};
                    buffer = buffer.substr(buffer.find(powerPins) + powerPins.length());
                    buffer = buffer.substr(buffer.find('<') + 1);

                    while (!false) {
                        paramEnd = buffer.find(',');
                        bool done{paramEnd == std::string::npos};
                        if (paramEnd == std::string::npos) paramEnd = buffer.find('>');

                        auto pinStr{buffer.substr(0, paramEnd)};
                        trimWhiteSpace(pinStr);
                        if (not pinStr.empty()) blade.powerPins.emplace_back(pinStr);

                        if (done) break;

                        buffer = buffer.substr(paramEnd + 1);
                    }
                } else if (buffer.find(simpleStr) != std::string::npos) {
                    bladeArray.blades.emplace_back();

                    auto& blade{bladeArray.blades.back()};
                    blade.type = BD_SIMPLE;

                    auto setupStar{[&](BladesPage::LED& star, int32_t& resistance) {
                        const auto paramEnd{buffer.find(',')};
                        BladesPage::LED ledSel{BladesPage::NONE};
                        auto paramStr{buffer.substr(0, paramEnd)};

                        const auto ledEnd{buffer.find('<')};
                        auto ledStr{paramStr.substr(0, ledEnd)};
                        trimWhiteSpace(ledStr);

                        for (auto [ led, configStr ] : BladesPage::LED_CONFIGSTRS) {
                            if (configStr == ledStr) {
                                ledSel = led;
                                break;
                            }
                        }

                        star = ledSel;
                        if (ledSel & BladesPage::USES_RESISTANCE) resistance = std::stoi(paramStr.substr(ledEnd + 1));

                        buffer = buffer.substr(paramEnd + 1);
                    }};

                    buffer = buffer.substr(buffer.find(simpleStr) + simpleStr.length());
                    buffer = buffer.substr(buffer.find('<') + 1);

                    setupStar(blade.Star1, blade.Star1Resistance);
                    setupStar(blade.Star2, blade.Star2Resistance);
                    setupStar(blade.Star3, blade.Star3Resistance);
                    setupStar(blade.Star4, blade.Star4Resistance);

                    while (!false) {
                        auto paramEnd{buffer.find(',')};
                        bool done{paramEnd == std::string::npos};
                        if (paramEnd == std::string::npos) paramEnd = buffer.find('>');

                        auto pinStr{buffer.substr(0, paramEnd)};
                        trimWhiteSpace(pinStr);
                        if (not pinStr.empty() and pinStr != "-1") blade.powerPins.emplace_back(pinStr);

                        if (done) break;

                        buffer = buffer.substr(paramEnd + 1);
                    }
                }

                ++bladesRead;
                buffer.clear();
                if (bladesRead == editor->settings->numBlades) {
                    reading = CONFIG_ARRAY;
                }
                continue;
            }

            buffer += chr;
        } else if (reading == CONFIG_ARRAY) {
            if (bladeSects.size() == 1) {
                if (chr == ')') bladeSects.pop_back();
                else buffer += chr;
            } else if (bladeSects.size() == 0) {
                if (chr == '(') bladeSects.push_back(chr);
            }

            if (not buffer.empty() and bladeSects.empty()) {
                trimWhiteSpace(buffer);
                bladeArray.name = buffer;

                if (bladeArray.blades.empty()) bladeArray.blades.emplace_back();

                for (BladeArrayDlg::BladeArray& array : editor->bladesPage->bladeArrayDlg->bladeArrays) {
                    if (array.name == bladeArray.name) {
                        array.value = bladeArray.value;
                        array.blades = bladeArray.blades;

                        if (array.value == 0 && array.name != "no_blade") {
                            array.name = "blade_in";
                        }
                    }
                }

                for (const auto& blade : bladeArray.blades) {
                    for (const auto& powerPin : blade.powerPins) {
                        if (editor->bladesPage->powerPins->FindString(powerPin) == wxNOT_FOUND) editor->bladesPage->powerPins->Append(powerPin);
                    }
                }

                reading = IN_ARRAY;
                buffer.clear();
            }
        }
    }
}

bool Configuration::runPreChecks(EditorWindow *editor) {
    if (editor->bladesPage->bladeArrayDlg->enableDetect->GetValue() && editor->bladesPage->bladeArrayDlg->detectPin->entry()->GetValue() == "") {
        ERR("Blade Detect Pin cannot be empty.");
    }
    if (editor->bladesPage->bladeArrayDlg->enableID->GetValue() && editor->bladesPage->bladeArrayDlg->IDPin->entry()->GetValue() == "") {
        ERR("Blade ID Pin cannot be empty.");
    }
    if ([&]() { for (const BladeArrayDlg::BladeArray& array : editor->bladesPage->bladeArrayDlg->bladeArrays) if (array.name == "") return true; return false; }()) {
        ERR("Blade Array Name cannot be empty.");
    }
    if (editor->bladesPage->bladeArrayDlg->enableID->GetValue() && editor->bladesPage->bladeArrayDlg->mode->entry()->GetStringSelection() == BLADE_ID_MODE_BRIDGED && editor->bladesPage->bladeArrayDlg->pullupPin->entry()->GetValue() == "") {
        ERR("Pullup Pin cannot be empty.");
    }
    if (editor->bladesPage->bladeArrayDlg->enableDetect->GetValue() && editor->bladesPage->bladeArrayDlg->enableID->GetValue() && editor->bladesPage->bladeArrayDlg->IDPin->entry()->GetValue() == editor->bladesPage->bladeArrayDlg->detectPin->entry()->GetValue()) {
        ERR("Blade ID Pin and Blade Detect Pin cannot be the same.");
    }

    auto getNumBlades{[](const BladeArrayDlg::BladeArray& array) {
            int32_t numBlades = 0;
            for (const BladesPage::BladeConfig& blade : array.blades) {
                blade.isSubBlade ? numBlades += blade.subBlades.size() : numBlades++;
            }
            return numBlades;
        }};
    auto bladeArrayLengthsEqual{[&]() -> bool {
            int32_t lastNumBlades = getNumBlades(editor->bladesPage->bladeArrayDlg->bladeArrays.at(0));
            for (const BladeArrayDlg::BladeArray& array : editor->bladesPage->bladeArrayDlg->bladeArrays) {
                if (getNumBlades(array) != lastNumBlades) return false;
                lastNumBlades = getNumBlades(array);
            }
            return true;
        }};
    if (not bladeArrayLengthsEqual()) {
        ERR("All Blade Arrays must be the same length.\n\nPlease add/remove blades to make them equal");
    }

    for (auto& bladeArray : editor->bladesPage->bladeArrayDlg->bladeArrays) {
        for (uint32_t idx = 0; idx < bladeArray.blades.size(); idx++) {
            auto& blade{bladeArray.blades.at(idx)};
            if (blade.type != BD_SIMPLE) continue;

            uint32_t numBlades{0};
            if (blade.Star1 != BladesPage::NONE) numBlades++;
            if (blade.Star2 != BladesPage::NONE) numBlades++;
            if (blade.Star3 != BladesPage::NONE) numBlades++;
            if (blade.Star4 != BladesPage::NONE) numBlades++;

            if (blade.powerPins.size() != numBlades) {
                auto bladeName{"Simple blade " + std::to_string(idx) + " in array \"" + bladeArray.name.ToStdString() + '"'};
                auto numActiveLEDs{std::to_string(numBlades)};
                ERR(bladeName + " with " + numActiveLEDs + " active LEDs should have " + numActiveLEDs + " power pins selected. (Has " + std::to_string(blade.powerPins.size()) + ')');
            }
        }
        for (auto& preset : bladeArray.presets) {
            for (auto& [ comment, style ] : preset.styles) {
                if (style.empty()) continue;
                const auto errorString{"Malformed bladestyle in " + (preset.name.empty() ? "unnamed preset" : std::string("preset \"") + preset.name.ToStdString() + '"') + " in blade array \"" + bladeArray.name.ToStdString() + "\"\n\n"};

                size_t depth{0};
                for (const char chr : style) {
                    if (chr == '<') ++depth;
                    else if (chr == '>') --depth;
                }
                if (depth != 0) {
                    ERR(errorString + "Mismatched \"<>\"");
                }

                depth = 0;
                for (const char chr : style) {
                    if (chr == '(') ++depth;
                    else if (chr == ')') --depth;
                }
                if (depth != 0) {
                    ERR(errorString + "Mismatched \"()\"");
                }
            }
        }
    }

    return true;
}

const Configuration::MapPair& Configuration::findInVMap(const Configuration::VMap& map, const std::string& search) {
    return *std::find_if(map.begin(), map.end(), [&](const MapPair& pair) { return (pair.second == search || pair.first == search); });
}
