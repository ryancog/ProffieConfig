#include "configuration.h"

#include "defines.h"
#include "mainwindow.h"
#include "generalpage.h"
#include "hardwarepage.h"
#include "presetspage.h"
#include "proppage.h"
#include "bladespage.h"
#include "bladeidpage.h"

#include <cstring>
#include <exception>
#include <wx/filedlg.h>

Configuration* Configuration::instance;
Configuration::Configuration() {
}

bool Configuration::outputConfig(const std::string& filePath) {
  PresetsPage::instance->update();
  BladesPage::instance->update();
  HardwarePage::instance->update();
  BladeIDPage::instance->update();

  if (!runPrechecks()) return false;

  std::ofstream configOutput(filePath);

  configOutput <<
      "/*" << std::endl <<
      "This configuration file was generated by ProffieConfig " VERSION ", created by Ryryog25." << std::endl <<
      "The tool can be found here: https://github.com/ryryog25/ProffieConfig" << std::endl <<
      "ProffieConfig is an All-In-One Proffieboard GUI Utility for managing configurations and applying them to your proffieboard" << std::endl <<
      "*/" << std::endl << std::endl;

  outputConfigTop(configOutput);
  outputConfigProp(configOutput);
  outputConfigPresets(configOutput);
  outputConfigButtons(configOutput);

  configOutput.close();
  return true;
}
bool Configuration::outputConfig() { return Configuration::outputConfig(CONFIG_PATH); }
bool Configuration::exportConfig() {
  wxFileDialog configLocation(MainWindow::instance, "Save ProffieOS Config File", "", "ProffieConfig_autogen.h", "C Header Files (*.h)|*.h", wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

  if (configLocation.ShowModal() == wxID_CANCEL) return false; // User Closed

  return Configuration::outputConfig(configLocation.GetPath().ToStdString());
}

void Configuration::outputConfigTop(std::ofstream& configOutput) {
  configOutput << "#ifdef CONFIG_TOP" << std::endl;
  outputConfigTopDefaults(configOutput);
  outputConfigTopGeneral(configOutput);
  outputConfigTopBladeAwareness(configOutput);
  outputConfigTopPropSpecific(configOutput);
  configOutput << "#endif" << std::endl << std::endl;

}
void Configuration::outputConfigTopDefaults(std::ofstream& configOutput) {
  if (GeneralPage::instance->massStorage->GetValue()) configOutput << "//PROFFIECONFIG ENABLE_MASS_STORAGE" << std::endl;
  if (GeneralPage::instance->webUSB->GetValue()) configOutput << "//PROFFIECONFIG ENABLE_WEBUSB" << std::endl;
  switch (parseBoardType(GeneralPage::instance->board->GetValue().ToStdString())) {
    case Configuration::ProffieBoard::V1:
      configOutput << "#include \"proffieboard_v1_config.h\"" << std::endl;
      break;
    case Configuration::ProffieBoard::V2:
      configOutput << "#include \"proffieboard_v2_config.h\"" << std::endl;
      break;
    case Configuration::ProffieBoard::V3:
      configOutput << "#include \"proffieboard_v3_config.h\"" << std::endl;
  }
  configOutput << "#define NUM_BLADES " << [=]() -> int32_t {
    int32_t numBlades = 0;
    for (const BladesPage::BladeConfig& blade : BladeIDPage::instance->bladeArrays[BladesPage::instance->bladeArray->GetSelection()].blades) numBlades += blade.subBlades.size() > 0 ? blade.subBlades.size() : 1;
    return numBlades;
  }() << std::endl;
  configOutput << "#define NUM_BUTTONS " << GeneralPage::instance->buttons->num->GetValue() << std::endl;
  configOutput << "#define VOLUME " << GeneralPage::instance->volume->num->GetValue() << std::endl;
  configOutput << "const unsigned int maxLedsPerStrip = " << GeneralPage::instance->maxLEDs->num->GetValue() << ";" << std::endl;
  configOutput << "#define CLASH_THRESHOLD_G " << GeneralPage::instance->clash->num->GetValue() << std::endl;
  // Implement Blade Detect Config
  configOutput << "#define ENABLE_AUDIO" << std::endl;
  configOutput << "#define ENABLE_WS2811" << std::endl;
  configOutput << "#define ENABLE_SD" << std::endl;
  configOutput << "#define ENABLE_MOTION" << std::endl;
  configOutput << "#define SHARED_POWER_PINS" << std::endl;
}
void Configuration::outputConfigTopGeneral(std::ofstream& configOutput) {
  if (GeneralPage::instance->colorSave->GetValue()) configOutput << "#define SAVE_COLOR_CHANGE" << std::endl;
  if (GeneralPage::instance->presetSave->GetValue()) configOutput << "#define SAVE_PRESET" << std::endl;
  if (GeneralPage::instance->volumeSave->GetValue()) configOutput << "#define SAVE_VOLUME" << std::endl;
  if (GeneralPage::instance->enableOLED->GetValue()) configOutput << "#define ENABLE_SSD1306" << std::endl;
  if (GeneralPage::instance->disableColor->GetValue()) configOutput << "#define DISABLE_COLOR_CHANGE" << std::endl;
  if (GeneralPage::instance->noTalkie->GetValue()) configOutput << "#define DISABLE_TALKIE" << std::endl;
  if (GeneralPage::instance->noBasicParsers->GetValue()) configOutput << "#define DISABLE_BASIC_PARSER_STYLES" << std::endl;
  if (GeneralPage::instance->disableDiagnosticCommands->GetValue()) configOutput << "#define DISABLE_DIAGNOSTIC_COMMANDS" << std::endl;
  if (GeneralPage::instance->enableDeveloperCommands->GetValue()) configOutput << "#define ENABLE_DEVELOPER_COMMANDS" << std::endl;
  configOutput << "#define PLI_OFF_TIME " << GeneralPage::instance->pliTime->num->GetValue() << " * 60 * 1000" << std::endl;
  configOutput << "#define IDLE_OFF_TIME " << GeneralPage::instance->idleTime->num->GetValue() << " * 60 * 1000" << std::endl;
  configOutput << "#define MOTION_TIMEOUT " << GeneralPage::instance->motionTime->num->GetValue() << " * 60 * 1000" << std::endl;
}
void Configuration::outputConfigTopBladeAwareness(std::ofstream& configOutput) {
  if (BladeIDPage::instance->enableDetect->GetValue()) configOutput << "#define BLADE_DETECT_PIN " << BladeIDPage::instance->detectPin->entry->GetValue() << std::endl;
  if (BladeIDPage::instance->enableID->GetValue()) {
    configOutput << "#define BLADE_ID_CLASS ";
    if (BladeIDPage::instance->mode->GetValue() == BLADE_ID_MODE_SNAPSHOT) configOutput << "SnapshotBladeID<" << BladeIDPage::instance->IDPin->entry->GetValue() << ">" << std::endl;
    if (BladeIDPage::instance->mode->GetValue() == BLADE_ID_MODE_EXTERNAL) configOutput << "ExternalPullupBladeID<" << BladeIDPage::instance->IDPin->entry->GetValue() << ", " << BladeIDPage::instance->pullupResistance->num->GetValue() << ">" << std::endl;
    if (BladeIDPage::instance->mode->GetValue() == BLADE_ID_MODE_BRIDGED) configOutput << "BridgedPullupBladeID<" << BladeIDPage::instance->IDPin->entry->GetValue() << ", " << BladeIDPage::instance->pullupPin->entry->GetValue() << ">" << std::endl;
    if (BladeIDPage::instance->enablePowerForID->GetValue()) {
      configOutput << "#define ENABLE_POWER_FOR_ID PowerPINS<";
      std::vector<std::string> powerPins;
      if (BladeIDPage::instance->powerPin1->GetValue()) powerPins.push_back("bladePowerPin1");
      if (BladeIDPage::instance->powerPin2->GetValue()) powerPins.push_back("bladePowerPin2");
      if (BladeIDPage::instance->powerPin3->GetValue()) powerPins.push_back("bladePowerPin3");
      if (BladeIDPage::instance->powerPin4->GetValue()) powerPins.push_back("bladePowerPin4");
      if (BladeIDPage::instance->powerPin5->GetValue()) powerPins.push_back("bladePowerPin5");
      if (BladeIDPage::instance->powerPin6->GetValue()) powerPins.push_back("bladePowerPin6");

      for (int32_t pin = 0; pin < static_cast<int32_t>(powerPins.size()); pin++) {
        configOutput << powerPins.at(pin);
        if (pin < static_cast<int32_t>(powerPins.size()) -1) configOutput << ",";
      }

      configOutput << ">" << std::endl;
    }
    if (BladeIDPage::instance->continuousScans->GetValue()) {
      configOutput << "#define BLADE_ID_SCAN_MILLIS " << BladeIDPage::instance->scanIDMillis->num->GetValue() << std::endl;
      configOutput << "#define BLADE_ID_TIMES " << BladeIDPage::instance->numIDTimes->num->GetValue() << std::endl;
    }
  }
}
void Configuration::outputConfigTopPropSpecific(std::ofstream& configOutput) {
  switch (parsePropSel(PropPage::instance->prop->GetValue().ToStdString())) {
    case Configuration::SaberProp::SA22C:
      outputConfigTopSA22C(configOutput);
      break;
    case Configuration::SaberProp::FETT263:
      outputConfigTopFett263(configOutput);
      break;
    case Configuration::SaberProp::BC:
      outputConfigTopBC(configOutput);
      break;
    case Configuration::SaberProp::SHTOK:
      // No Options
      break;
    case Configuration::SaberProp::CAIWYN:
      outputConfigTopCaiwyn(configOutput);
      break;
    default:
      // No Options
      break;
  }
}
void Configuration::outputConfigTopSA22C(std::ofstream& configOutput) {
  if (PropPage::instance->noLockupHold->GetValue()) configOutput << "#define SA22C_NO_LOCKUP_HOLD" << std::endl;
  if (PropPage::instance->stabOn->GetValue()) configOutput << "#define SA22C_STAB_ON" << std::endl;
  if (PropPage::instance->swingOn->GetValue()) {
    configOutput << "#define SA22C_SWING_ON" << std::endl;
    configOutput << "#define SA22C_SWING_ON_SPEED " << PropPage::instance->swingOnSpeed->num->GetValue() << std::endl;
  }
  if (PropPage::instance->twistOn->GetValue()) configOutput << "#define SA22C_TWIST_ON" << std::endl;
  if (PropPage::instance->thrustOn->GetValue()) configOutput << "#define SA22C_THRUST_ON" << std::endl;
  if (PropPage::instance->twistOff->GetValue()) configOutput << "#define SA22C_TWIST_OFF" << std::endl;
  if (PropPage::instance->forcePush->GetValue()) {
    configOutput << "#define SA22C_FORCE_PUSH" << std::endl;
    configOutput << "#define SA22C_FORCE_PUSH_LENGTH " << PropPage::instance->forcePushLength->num->GetValue() << std::endl;
  }
  if (PropPage::instance->gestureEnBattle->GetValue())
    configOutput << "#define GESTURE_AUTO_BATTLE_MODE" << std::endl;
  configOutput << "#define SA22C_LOCKUP_DELAY " << PropPage::instance->lockupDelay->num->GetValue() << std::endl;
}
void Configuration::outputConfigTopFett263(std::ofstream& configOutput) {
  if (PropPage::instance->stabOn->GetValue()) {
    if (PropPage::instance->stabOnFast->GetValue()) configOutput << "#define FETT263_STAB_ON" << std::endl;
    else if (PropPage::instance->stabOnPreon->GetValue()) configOutput << "#define FETT263_STAB_ON_PREON" << std::endl;
    if (PropPage::instance->stabOnNoBattle->GetValue()) configOutput << "#define FETT263_STAB_ON_NO_BM" << std::endl;
  }
  if (PropPage::instance->swingOn->GetValue()) {
    if (PropPage::instance->swingOnFast->GetValue()) configOutput << "#define FETT263_SWING_ON" << std::endl;
    else if (PropPage::instance->swingOnPreon->GetValue()) configOutput << "#define FETT263_SWING_ON_PREON" << std::endl;
    if (PropPage::instance->swingOnNoBattle->GetValue()) configOutput << "#define FETT263_SWING_ON_NO_BM" << std::endl;
    configOutput << "#define FETT263_SWING_ON_SPEED " << PropPage::instance->swingOnSpeed->num->GetValue() << std::endl;
  }
  if (PropPage::instance->thrustOn->GetValue()) {
    if (PropPage::instance->thrustOnFast->GetValue()) configOutput << "#define FETT263_THRUST_ON" << std::endl;
    else if (PropPage::instance->thrustOnPreon->GetValue()) configOutput << "#define FETT263_THRUST_ON_PREON" << std::endl;
    if (PropPage::instance->thrustOnNoBattle->GetValue()) configOutput << "#define FETT263_THRUST_ON_NO_BM" << std::endl;
  }
  if (PropPage::instance->twistOn->GetValue()) {
    if (PropPage::instance->twistOnFast->GetValue()) configOutput << "#define FETT263_TWIST_ON" << std::endl;
    else if (PropPage::instance->twistOnPreon->GetValue()) configOutput << "#define FETT263_TWIST_ON_PREON" << std::endl;
    if (PropPage::instance->twistOnNoBattle->GetValue()) configOutput << "#define FETT263_TWIST_ON_NO_BM" << std::endl;
  }
  if (PropPage::instance->twistOff->GetValue()) {
    if (PropPage::instance->twistOffFast->GetValue()) configOutput << "#define FETT263_TWIST_OFF_NO_POSTOFF" << std::endl;
    else if (PropPage::instance->twistOffPostoff->GetValue()) configOutput << "#define FETT263_TWIST_OFF" << std::endl;
  }

  if (PropPage::instance->pwrHoldOff->GetValue()) configOutput << "#define FETT263_HOLD_BUTTON_OFF" << std::endl;
  if (PropPage::instance->auxHoldLockup->GetValue()) configOutput << "#define FETT263_HOLD_BUTTON_LOCKUP" << std::endl;
  if (PropPage::instance->meltGestureAlways->GetValue()) configOutput << "#define FETT263_USE_BC_MELT_STAB" << std::endl;
  if (PropPage::instance->volumeCircular->GetValue()) configOutput << "#define FETT263_CIRCULAR_VOLUME_MENU" << std::endl;
  if (PropPage::instance->brightnessCircular->GetValue()) configOutput << "#define FETT263_CIRCULAR_DIM_MENU" << std::endl;
  if (PropPage::instance->pwrWakeGesture->GetValue()) configOutput << "#define FETT263_MOTION_WAKE_POWER_BUTTON" << std::endl;

  if (PropPage::instance->editEnable->GetValue()) {
    configOutput << "#define ENABLE_ALL_EDIT_OPTIONS" << std::endl;
    if (PropPage::instance->editMode->GetValue()) configOutput << "#define FETT263_EDIT_MODE_MENU" << std::endl;
    if (PropPage::instance->editSettings->GetValue()) configOutput << "#define FETT263_EDIT_SETTINGS_MENU" << std::endl;
  }

  if (PropPage::instance->beepErrors->GetValue()) configOutput << "#define DISABLE_TALKIE" << std::endl;
  if (!PropPage::instance->trackPlayerPrompts->GetValue()) configOutput << "#define FETT263_TRACK_PLAYER_NO_PROMPTS" << std::endl;
  if (PropPage::instance->spokenColors->GetValue()) {
    configOutput << "#define FETT263_SAY_COLOR_LIST" << std::endl;
    configOutput << "#define FETT263_SAY_COLOR_LIST_CC" << std::endl;
  }
  if (PropPage::instance->spokenBatteryPercent->GetValue()) configOutput << "#define FETT263_SAY_BATTERY_PERCENT" << std::endl;
  if (PropPage::instance->spokenBatteryVolts->GetValue()) configOutput << "#define FETT263_SAY_BATTERY_VOLTS" << std::endl;

  if (PropPage::instance->forcePush->GetValue()) configOutput << "#define FETT263_FORCE_PUSH_ALWAYS_ON" << std::endl;
  else if (PropPage::instance->forcePushBM->GetValue()) configOutput << "#define FETT263_FORCE_PUSH" << std::endl;
  if (PropPage::instance->forcePush->GetValue() || PropPage::instance->forcePushBM->GetValue()) configOutput << "#define FETT263_FORCE_PUSH_LENGTH " << PropPage::instance->forcePushLength->num->GetValue() << std::endl;


  if (!PropPage::instance->enableQuotePlayer->GetValue()) configOutput << "#define FETT263_DISABLE_QUOTE_PLAYER" << std::endl;
  else {
    if (PropPage::instance->randomizeQuotePlayer->GetValue()) configOutput << "#define FETT263_RANDOMIZE_QUOTE_PLAYER" << std::endl;
    if (PropPage::instance->quotePlayerDefault->GetValue()) configOutput << "#define FETT263_QUOTE_PLAYER_START_ON" << std::endl;
    // if forcePlayerDefault is default already, no define needed
  }

  if (!PropPage::instance->noExtraEffects->GetValue()) {
    if (PropPage::instance->specialAbilities->GetValue()) configOutput << "#define FETT263_SPECIAL_ABILITIES" << std::endl;
    if (PropPage::instance->multiPhase->GetValue()) configOutput << "#define FETT263_MULTI_PHASE" << std::endl;
  }
  if (PropPage::instance->saveChoreo->GetValue()) configOutput << "#define FETT263_SAVE_CHOREOGRAPHY" << std::endl;
  else if (PropPage::instance->spinMode->GetValue()) configOutput << "#define FETT263_SPIN_MODE" << std::endl;
  if (PropPage::instance->saveGesture->GetValue()) configOutput << "#define FETT263_SAVE_GESTURE_OFF" << std::endl;
  if (PropPage::instance->dualModeSound->GetValue()) configOutput << "#define FETT263_DUAL_MODE_SOUND" << std::endl;
  if (PropPage::instance->quickPresetSelect->GetValue()) configOutput << "#define FETT263_QUICK_SELECT_ON_BOOT" << std::endl;
  if (!PropPage::instance->multiBlast->GetValue()) configOutput << "#define FETT263_DISABLE_MULTI_BLAST" << std::endl;
  if (PropPage::instance->multiBlastDisableToggle->GetValue()) configOutput << "#define FETT263_DISABLE_MULTI_BLAST_TOGGLE" << std::endl;

  if (!PropPage::instance->fontChangeOTF->GetValue()) configOutput << "#define FETT263_DISABLE_CHANGE_FONT" << std::endl;
  if (!PropPage::instance->styleChangeOTF->GetValue()) configOutput << "#define FETT263_DISABLE_CHANGE_STYLE" << std::endl;
  if (!PropPage::instance->presetCopyOTF->GetValue()) configOutput << "#define FETT263_DISABLE_COPY_PRESET" << std::endl;
  if (PropPage::instance->clashStrengthSound->GetValue()) {
    configOutput << "#define FETT263_CLASH_STRENGTH_SOUND" << std::endl;
    configOutput << "#define FETT263_MAX_CLASH " << PropPage::instance->clashStrengthSoundMaxClash->num->GetValue() << std::endl;
  }

  // if battleModeToggle is default
  if (PropPage::instance->battleModeAlways->GetValue()) configOutput << "#define FETT263_BATTLE_MODE_ALWAYS_ON" << std::endl;
  if (PropPage::instance->battleModeOnStart->GetValue()) configOutput << "#define FETT263_BATTLE_MODE_START_ON" << std::endl;
  if (PropPage::instance->battleModeNoToggle->GetValue()) configOutput << "#define FETT263_DISABLE_BM_TOGGLE" << std::endl;
  configOutput << "#define FETT263_LOCKUP_DELAY " << PropPage::instance->lockupDelay->num->GetValue() << std::endl;
  configOutput << "#define FETT263_BM_CLASH_DETECT " << PropPage::instance->battleModeClash->num->GetValue() << std::endl;

  if (PropPage::instance->battleModeDisablePWR->GetValue()) configOutput << "#define FETT263_BM_DISABLE_OFF_BUTTON" << std::endl;
}
void Configuration::outputConfigTopBC(std::ofstream& configOutput) {
  if (PropPage::instance->stabOn->GetValue()) configOutput << "#define BC_STAB_ON" << std::endl;
  if (PropPage::instance->swingOn->GetValue()) {
    configOutput << "#define BC_SWING_ON" << std::endl;
    configOutput << "#define BC_SWING_ON_SPEED " << PropPage::instance->swingOnSpeed->num->GetValue() << std::endl;
  }
  if (PropPage::instance->twistOn->GetValue()) configOutput << "#define BC_TWIST_ON" << std::endl;
  if (PropPage::instance->thrustOn->GetValue()) configOutput << "#define BC_THRUST_ON" << std::endl;
  if (PropPage::instance->twistOff->GetValue()) configOutput << "#define BC_TWIST_OFF" << std::endl;
  if (PropPage::instance->forcePush->GetValue()) {
    configOutput << "#define BC_FORCE_PUSH" << std::endl;
    configOutput << "#define BC_FORCE_PUSH_LENGTH " << PropPage::instance->forcePushLength->num->GetValue() << std::endl;
  }
  if (PropPage::instance->gestureEnBattle->GetValue()) configOutput << "#define GESTURE_AUTO_BATTLE_MODE" << std::endl;
  if (PropPage::instance->disableGestureNoBlade->GetValue()) configOutput << "#define NO_BLADE_NO_GEST_ONOFF" << std::endl;
  if (PropPage::instance->multiBlastSwing->GetValue()) configOutput << "#define ENABLE_AUTO_SWING_BLAST" << std::endl;
}
void Configuration::outputConfigTopCaiwyn(std::ofstream& configOutput) {
  if (PropPage::instance->pwrClash->GetValue()) configOutput << "#define CAIWYN_BUTTON_CLASH" << std::endl;
  if (PropPage::instance->pwrLockup->GetValue()) configOutput << "#define CAIWYN_BUTTON_LOCKUP" << std::endl;
}

void Configuration::outputConfigProp(std::ofstream& configOutput)
{
  configOutput << "#ifdef CONFIG_PROP" << std::endl;
  switch (Configuration::parsePropSel(PropPage::instance->prop->GetValue().ToStdString())) {
    case Configuration::SaberProp::SA22C:
      configOutput << "#include \"../props/saber_sa22c_buttons.h\"" << std::endl;
      break;
    case Configuration::SaberProp::FETT263:
      configOutput << "#include \"../props/saber_fett263_buttons.h\"" << std::endl;
      break;
    case Configuration::SaberProp::BC:
      configOutput << "#include \"../props/saber_BC_buttons.h\"" << std::endl;
      break;
    case Configuration::SaberProp::SHTOK:
      configOutput << "#include \"../props/saber_shtok_buttons.h\"" << std::endl;
      break;
    case Configuration::SaberProp::CAIWYN:
      configOutput << "#include \"../props/saber_caiwyn_buttons.h\"" << std::endl;
      break;
    default: break;
  }
  configOutput << "#endif" << std:: endl << std::endl; // CONFIG_PROP
}
void Configuration::outputConfigPresets(std::ofstream& configOutput) {
  configOutput << "#ifdef CONFIG_PRESETS" << std::endl;
  outputConfigPresetsStyles(configOutput);
  outputConfigPresetsBlades(configOutput);
  configOutput << "#endif" << std::endl << std::endl;
}
void Configuration::outputConfigPresetsStyles(std::ofstream& configOutput) {
  for (const BladeIDPage::BladeArray& bladeArray : BladeIDPage::instance->bladeArrays) {
    configOutput << "Preset " << bladeArray.name << "[] = {" << std::endl;
    for (const PresetsPage::PresetConfig& preset : bladeArray.presets) {
      configOutput << "\t{ \"" << preset.dirs << "\", \"" << preset.track << "\"," << std::endl;
      if (preset.styles.size() > 0) for (const wxString& style : preset.styles) configOutput << "\t\t" << style << "," << std::endl;
      else configOutput << "\t\t," << std::endl;
      configOutput << "\t\t\"" << preset.name << "\"}";
      // If not the last one, add comma
      if (&bladeArray.presets[bladeArray.presets.size() - 1] != &preset) configOutput << ",";
      configOutput << std::endl;
    }
    configOutput << "};" << std::endl;
  }
}
void Configuration::outputConfigPresetsBlades(std::ofstream& configOutput) {
  configOutput << "BladeConfig blades[] = {" << std::endl;
  for (const BladeIDPage::BladeArray& bladeArray : BladeIDPage::instance->bladeArrays) {
    configOutput << "\t{ " << (bladeArray.name == "no_blade" ? "NO_BLADE" : std::to_string(bladeArray.value)) << "," << std::endl;
    for (const BladesPage::BladeConfig& blade : bladeArray.blades) {
      if (blade.type == BD_PIXELRGB || blade.type == BD_PIXELRGBW) {
        bool firstSub = true;
        if (blade.isSubBlade) for (BladesPage::BladeConfig::subBladeInfo subBlade : blade.subBlades) {
            if (blade.subBladeWithStride) configOutput << "\t\tSubBladeWithStride( ";
            else /* if not with stride*/ configOutput << "\t\tSubBlade( ";
            configOutput << subBlade.startPixel << ", " << subBlade.endPixel << ", ";
            if (firstSub) {
              genWS281X(configOutput, blade);
              configOutput << ")," << std::endl;
            } else {
              configOutput << "NULL)," << std::endl;
            }
            firstSub = false;
          } else {
          configOutput << "\t\t";
          genWS281X(configOutput, blade);
          configOutput << "," << std::endl;
        }
      } else if (blade.type == BD_TRISTAR || blade.type == BD_QUADSTAR) {
        bool powerPins[4]{true, true, true, true};
        configOutput << "\t\tSimpleBladePtr<";
        if (blade.Star1 != BD_NORESISTANCE) configOutput << "CreeXPE2" << blade.Star1 << "Template<" << blade.Star1Resistance << ">, ";
        else {
          configOutput << "NoLED, ";
          powerPins[0] = false;
        }
        if (blade.Star2 != BD_NORESISTANCE) configOutput << "CreeXPE2" << blade.Star2 << "Template<" << blade.Star2Resistance << ">, ";
        else {
          configOutput << "NoLED, ";
          powerPins[1] = false;
        }
        if (blade.Star3 != BD_NORESISTANCE) configOutput << "CreeXPE2" << blade.Star3 << "Template<" << blade.Star3Resistance << ">, ";
        else {
          configOutput << "NoLED, ";
          powerPins[2] = false;
        }
        if (blade.Star4 != BD_NORESISTANCE && blade.type == BD_QUADSTAR) configOutput << "CreeXPE2" << blade.Star4 << "Template<" << blade.Star4Resistance << ">, ";
        else {
          configOutput << "NoLED, ";
          powerPins[3] = false;
        }

        BladesPage::BladeConfig tempBlade = blade;
        for (int32_t powerPin = 0; powerPin < 4; powerPin++) {
          if (powerPins[powerPin]) {
            if (tempBlade.usePowerPin1) {
              configOutput << "bladePowerPin1";
              tempBlade.usePowerPin1 = false;
            } else if (tempBlade.usePowerPin2) {
              configOutput << "bladePowerPin2";
              tempBlade.usePowerPin2 = false;
            } else if (tempBlade.usePowerPin3) {
              configOutput << "bladePowerPin3";
              tempBlade.usePowerPin3 = false;
            } else if (tempBlade.usePowerPin4) {
              configOutput << "bladePowerPin4";
              tempBlade.usePowerPin4 = false;
            } else if (tempBlade.usePowerPin5) {
              configOutput << "bladePowerPin5";
              tempBlade.usePowerPin5 = false;
            } else if (tempBlade.usePowerPin6) {
              configOutput << "bladePowerPin6";
              tempBlade.usePowerPin6 = false;
            } else configOutput << "-1";
          } else {
            configOutput << "-1";
          }

          if (powerPin != 3) configOutput << ", ";
        }
        configOutput << ">()," << std::endl;
      } else if (blade.type == BD_SINGLELED) {
        configOutput << "\t\tSimpleBladePtr<CreeXPE2WhiteTemplate<550>, NoLED, NoLED, NoLED, ";
        if (blade.usePowerPin1) {
          configOutput << "bladePowerPin1, ";
        } else if (blade.usePowerPin2) {
          configOutput << "bladePowerPin2, ";
        } else if (blade.usePowerPin3) {
          configOutput << "bladePowerPin3, ";
        } else if (blade.usePowerPin4) {
          configOutput << "bladePowerPin4, ";
        } else if (blade.usePowerPin5) {
          configOutput << "bladePowerPin5, ";
        } else if (blade.usePowerPin6) {
          configOutput << "bladePowerPin6, ";
        } else configOutput << "-1, ";
        configOutput << "-1, -1, -1>()," << std::endl;
      }
    }
    configOutput << "\t\tCONFIGARRAY(" << bladeArray.name << "), \"" << bladeArray.name << "\"" << std::endl << "\t}";
    if (&bladeArray != &BladeIDPage::instance->bladeArrays[BladeIDPage::instance->bladeArrays.size() - 1]) configOutput << ",";
    configOutput << std::endl;
  }
  configOutput << "};" << std::endl;
}
void Configuration::genWS281X(std::ofstream& configOutput, const BladesPage::BladeConfig& blade) {
  wxString bladePin = blade.dataPin;
  wxString bladeColor = blade.type == BD_PIXELRGB || blade.useRGBWithWhite ? blade.colorType : [=](wxString colorType) -> wxString { colorType.replace(colorType.find("W"), 1, "w"); return colorType; }(blade.colorType);

  configOutput << "WS281XBladePtr<" << blade.numPixels << ", " << bladePin << ", Color8::" << bladeColor << ", PowerPINS<";
  if (blade.usePowerPin1) {
    configOutput << "bladePowerPin1";
    if (blade.usePowerPin2 || blade.usePowerPin3 || blade.usePowerPin4 || blade.usePowerPin5 || blade.usePowerPin6) configOutput << ", ";
  }
  if (blade.usePowerPin2) {
    configOutput << "bladePowerPin2";
    if (blade.usePowerPin3 || blade.usePowerPin4 || blade.usePowerPin5 || blade.usePowerPin6) configOutput << ", ";
  }
  if (blade.usePowerPin3) {
    configOutput << "bladePowerPin3";
    if (blade.usePowerPin4 || blade.usePowerPin5 || blade.usePowerPin6) configOutput << ", ";
  }
  if (blade.usePowerPin4) {
    configOutput << "bladePowerPin4";
    if (blade.usePowerPin5 || blade.usePowerPin6) configOutput << ", ";
  }
  if (blade.usePowerPin5) {
    configOutput << "bladePowerPin5";
    if (blade.usePowerPin6) configOutput << ", ";
  }
  if (blade.usePowerPin6) {
    configOutput << "bladePowerPin6";
  }
  configOutput << ">>()";
};
void Configuration::outputConfigButtons(std::ofstream& configOutput) {
  configOutput << "#ifdef CONFIG_BUTTONS" << std::endl;
  configOutput << "Button PowerButton(BUTTON_POWER, powerButtonPin, \"pow\");" << std::endl;
  if (GeneralPage::instance->buttons->num->GetValue() >= 2) configOutput << "Button AuxButton(BUTTON_AUX, auxPin, \"aux\");" << std::endl;
  if (GeneralPage::instance->buttons->num->GetValue() == 3) configOutput << "Button Aux2Button(BUTTON_AUX2, aux2Pin, \"aux\");" << std::endl; // figure out aux2 syntax
  configOutput << "#endif" << std::endl << std::endl; // CONFIG_BUTTONS
}

void Configuration::readConfig(const std::string& filePath) {
  std::ifstream file(filePath);
  if (!file.is_open()) return;

  try {
    std::string section;
    BladeIDPage::instance->bladeArrays.clear();
    while (!file.eof()) {
      file >> section;
      if (section == "//") {
        getline(file, section);
        continue;
      }
      if (std::strstr(section.data(), "/*")) {
        while (!file.eof()) {
          if (std::strstr(section.data(), "*/")) break;
          file >> section;
        }
        continue;
      }
      if (section == "#ifdef") {
        file >> section;
        if (section == "CONFIG_TOP") Configuration::readConfigTop(file);
        if (section == "CONFIG_PROP") Configuration::readConfigProp(file);
        if (section == "CONFIG_PRESETS") Configuration::readConfigPresets(file);
        if (section == "CONFIG_STYLES") Configuration::readConfigStyles(file);
      }
    }
  } catch (std::exception& e) {
    std::string errorMessage = "There was an error parsing config, please ensure it is valid:\n\n";
    errorMessage += e.what();

    // Restore App State
    MainWindow::instance->Destroy();
    MainWindow::instance = new MainWindow();

    wxMessageBox(errorMessage, "Config Read Error", wxOK, MainWindow::instance);
  }

  //GeneralPage::update();
  PropPage::instance->update();
  BladesPage::instance->update();
  PresetsPage::instance->update();
}
void Configuration::readConfig() {
  struct stat buffer;
  if (stat(CONFIG_PATH, &buffer) != 0) {
    if (wxMessageBox("No existing configuration file was detected. Would you like to import one?", "ProffieConfig", wxICON_INFORMATION | wxYES_NO | wxYES_DEFAULT) == wxYES) {
      Configuration::importConfig();
      MainWindow::instance->Show(true);
      return;
    } else return;
  }

  Configuration::readConfig(CONFIG_PATH);
}
void Configuration::importConfig() {
  wxFileDialog configLocation(MainWindow::instance, "Choose ProffieOS Config File", "", "", "C Header Files (*.h)|*.h", wxFD_OPEN | wxFD_FILE_MUST_EXIST);

  if (configLocation.ShowModal() == wxID_CANCEL) return; // User Closed

  MainWindow::instance->Destroy();
  MainWindow::instance = new MainWindow();

  Configuration::readConfig(configLocation.GetPath().ToStdString());
}

void Configuration::readConfigTop(std::ifstream& file) {
  std::string element;
  while (!file.eof() && element != "#endif") {
    file >> element;
    if (element == "//") {
      getline(file, element);
      continue;
    }
    if (std::strstr(element.data(), "/*")) {
      while (!file.eof()) {
        if (std::strstr(element.data(), "*/")) break;
        file >> element;
      }
      continue;
    }
    if (element == "#define" && !file.eof()) {
      getline(file, element);
      Configuration::readDefine(element);
    } else if (element == "const" && !file.eof()) {
      getline(file, element);
      std::strtok(element.data(), "="); // unsigned int maxLedsPerStrip =
      element = std::strtok(nullptr, " ;");
      GeneralPage::instance->maxLEDs->num->SetValue(std::stoi(element));
    } else if (element == "#include" && !file.eof()) {
      file >> element;
      if (std::strstr(element.c_str(), "v1") != NULL) {
        GeneralPage::instance->board->SetSelection(0);
      } else if (std::strstr(element.c_str(), "v2") != NULL) {
        GeneralPage::instance->board->SetSelection(1);
      } else if (std::strstr(element.c_str(), "v3") != NULL) {
        GeneralPage::instance->board->SetSelection(2);
      }
    } else if (element == "//PROFFIECONFIG") {
      file >> element;
      if (element == "ENABLE_MASS_STORAGE") GeneralPage::instance->massStorage->SetValue(true);
      if (element == "ENABLE_WEBUSB") GeneralPage::instance->webUSB->SetValue(true);
    }
  }
}
void Configuration::readConfigProp(std::ifstream& file) {
  std::string element;
  while (!file.eof() && element != "#endif") {
    file >> element;
    if (std::strstr(element.data(), "sa22c") != nullptr) PropPage::instance->prop->SetValue("SA22C");
    if (std::strstr(element.data(), "fett263") != nullptr) PropPage::instance->prop->SetValue("Fett263");
    if (std::strstr(element.data(), "shtok") != nullptr) PropPage::instance->prop->SetValue("Shtok");
    if (std::strstr(element.data(), "BC") != nullptr) PropPage::instance->prop->SetValue("BC");
    if (std::strstr(element.data(), "caiwyn") != nullptr) PropPage::instance->prop->SetValue("Caiwyn");
  }
}
void Configuration::readConfigPresets(std::ifstream& file) {
  std::string element;
  while (!file.eof() && element != "#endif") {
    file >> element;
    if (element == "//") {
      getline(file, element);
      continue;
    }
    if (std::strstr(element.data(), "/*")) {
      while (!file.eof()) {
        if (std::strstr(element.data(), "*/")) break;
        file >> element;
      }
      continue;
    }
    if (element == "Preset") readPresetArray(file);
    if (element == "BladeConfig") readBladeArray(file);
  }
}
void Configuration::readConfigStyles(std::ifstream& file) {
  std::string element;
  std::string styleName;
  std::string style;

  file >> element;
  while (!file.eof() && element != "#endif") {
    if (element == "using") {
      file >> element;
      styleName = element;

      file >> element; // Clear "="

      style = "";
      while (style.find(";") == std::string::npos) {
        file >> element;
        style += element;
      }
      style.erase(style.rfind(";")); // remove trailing ";"
      style.erase(std::remove(style.begin(), style.end(), '\n'), style.end()); // remove newlines

      // Remove potential StylePtr<> syntax
      if (style.find("StylePtr") != std::string::npos) {
        style.erase(style.find("StylePtr<"), 9);
        style.erase(style.rfind(">()"), 3);
      }

      Configuration::replaceStyles(styleName, style);
    }
    file >> element;
  }
}
void Configuration::readDefine(std::string& define) {
# define CHKDEF(str) if (std::strncmp(define.c_str(), str, strlen(str)) == 0)
# define CHKPRP(str) if (std::strstr(define.c_str(), str) != nullptr)
# define DEFVAL std::strtok(nullptr, " \n\r")
# define DEFNUM std::stod(DEFVAL)
  define = std::strtok(&define[0], " ");

  // General Defines
  CHKDEF("NUM_BLADES") {
   numBlades = DEFNUM;
  }
  CHKDEF("NUM_BUTTONS") GeneralPage::instance->buttons->num->SetValue(DEFNUM);
  CHKDEF("VOLUME") GeneralPage::instance->volume->num->SetValue(DEFNUM);
  CHKDEF("CLASH_THRESHOLD_G") GeneralPage::instance->clash->num->SetValue(DEFNUM);
  CHKDEF("SAVE_STATE") {
    GeneralPage::instance->colorSave->SetValue(true);
    GeneralPage::instance->presetSave->SetValue(true);
    GeneralPage::instance->volumeSave->SetValue(true);
  }
  CHKDEF("SAVE_COLOR_CHANGE") GeneralPage::instance->colorSave->SetValue(true);
  CHKDEF("SAVE_PRESET") GeneralPage::instance->presetSave->SetValue(true);
  CHKDEF("SAVE_VOLUME") GeneralPage::instance->volumeSave->SetValue(true);
  CHKDEF("ENABLE_SSD1306") GeneralPage::instance->enableOLED->SetValue(true);
  CHKDEF("DISABLE_COLOR_CHANGE") GeneralPage::instance->disableColor->SetValue(true);
  CHKDEF("DISABLE_TALKIE") GeneralPage::instance->noTalkie->SetValue(true);
  CHKDEF("DISABLE_BASIC_PARSER_STYLES") GeneralPage::instance->noBasicParsers->SetValue(true);
  CHKDEF("ENABLE_DEVELOPER_COMMANDS") GeneralPage::instance->enableDeveloperCommands->SetValue(true);
  CHKDEF("DISABLE_DIAGNOSTIC_COMMANDS") GeneralPage::instance->disableDiagnosticCommands->SetValue(true);
  CHKDEF("PLI_OFF_TIME") GeneralPage::instance->pliTime->num->SetValue(DEFNUM);
  CHKDEF("IDLE_OFF_TIME") GeneralPage::instance->idleTime->num->SetValue(DEFNUM);
  CHKDEF("MOTION_TIMEOUT") GeneralPage::instance->motionTime->num->SetValue(DEFNUM);

  // Blade Awareness
  CHKDEF("BLADE_DETECT_PIN") {
    BladeIDPage::instance->enableDetect->SetValue(true);
    BladeIDPage::instance->detectPin->entry->SetValue(DEFVAL);
  }
  CHKDEF("BLADE_ID_CLASS") {
    BladeIDPage::instance->enableID->SetValue(true);
    define = std::strtok(nullptr, "< ");
    if (define == "SnapshotBladeID") {
      BladeIDPage::instance->mode->SetValue(BLADE_ID_MODE_SNAPSHOT);
      BladeIDPage::instance->IDPin->entry->SetValue(std::strtok(nullptr, "<> "));
    } else if (define == "ExternalPullupBladeID") {
      BladeIDPage::instance->mode->SetValue(BLADE_ID_MODE_EXTERNAL);
      BladeIDPage::instance->IDPin->entry->SetValue(std::strtok(nullptr, "<, "));
      BladeIDPage::instance->pullupResistance->num->SetValue(std::stod(std::strtok(nullptr, ",> ")));
    } else if (define == "BridgedPullupBladeID") {
      BladeIDPage::instance->mode->SetValue(BLADE_ID_MODE_BRIDGED);
      BladeIDPage::instance->IDPin->entry->SetValue(std::strtok(nullptr, "<, "));
      BladeIDPage::instance->pullupPin->entry->SetValue(std::strtok(nullptr, ",> "));
    }
  }
  CHKDEF("ENABLE_POWER_FOR_ID") {
    BladeIDPage::instance->enablePowerForID->SetValue(true);
    std::strtok(nullptr, "<");
    char* pwrPinTest = std::strtok(nullptr, "<>, ");
    while (pwrPinTest != nullptr) {
      define = pwrPinTest;
      if (define == "bladePowerPin1") BladeIDPage::instance->powerPin1->SetValue(true);
      if (define == "bladePowerPin2") BladeIDPage::instance->powerPin2->SetValue(true);
      if (define == "bladePowerPin3") BladeIDPage::instance->powerPin3->SetValue(true);
      if (define == "bladePowerPin4") BladeIDPage::instance->powerPin4->SetValue(true);
      if (define == "bladePowerPin5") BladeIDPage::instance->powerPin5->SetValue(true);
      if (define == "bladePowerPin6") BladeIDPage::instance->powerPin6->SetValue(true);

      pwrPinTest = std::strtok(nullptr, "<>, ");
    }
  }
  CHKDEF("BLADE_ID_SCAN_MILLIS") {
    BladeIDPage::instance->continuousScans->SetValue(true);
    BladeIDPage::instance->scanIDMillis->num->SetValue(DEFNUM);
  }
  CHKDEF("BLADE_ID_TIMES") {
    BladeIDPage::instance->continuousScans->SetValue(true);
    BladeIDPage::instance->numIDTimes->num->SetValue(DEFNUM);
  }

  // Prop Specific
  CHKPRP("STAB_ON") PropPage::instance->stabOn->SetValue(true);
  CHKPRP("STAB_ON_PREON") PropPage::instance->stabOnPreon->SetValue(true);
  CHKPRP("STAB_ON_NO_BM") PropPage::instance->stabOnNoBattle->SetValue(true);
  CHKPRP("SWING_ON") PropPage::instance->swingOn->SetValue(true);
  CHKPRP("SWING_ON_PREON") PropPage::instance->swingOnPreon->SetValue(true);
  CHKPRP("SWING_ON_NO_BM") PropPage::instance->swingOnNoBattle->SetValue(true);
  CHKPRP("SWING_ON_SPEED") PropPage::instance->swingOnSpeed->num->SetValue(DEFNUM);
  CHKPRP("THRUST_ON") PropPage::instance->thrustOn->SetValue(true);
  CHKPRP("THRUST_ON_PREON") PropPage::instance->thrustOnPreon->SetValue(true);
  CHKPRP("THRUST_ON_NO_BM") PropPage::instance->thrustOnNoBattle->SetValue(true);
  CHKPRP("TWIST_ON") PropPage::instance->twistOn->SetValue(true);
  CHKPRP("TWIST_ON_PREON") PropPage::instance->twistOnPreon->SetValue(true);
  CHKPRP("TWIST_ON_NO_BM") PropPage::instance->twistOnNoBattle->SetValue(true);
  CHKPRP("TWIST_OFF") PropPage::instance->twistOff->SetValue(true);
  CHKPRP("TWIST_OFF_NO_POSTOFF") PropPage::instance->twistOffFast->SetValue(true);

  CHKPRP("NO_LOCKUP_HOLD") PropPage::instance->noLockupHold->SetValue(true);
  CHKPRP("ENABLE_AUTO_SWING_BLAST") PropPage::instance->multiBlastSwing->SetValue(true);
  CHKPRP("NO_BLADE_NO_GEST_ONOFF") PropPage::instance->disableGestureNoBlade->SetValue(true);
  CHKPRP("BUTTON_CLASH") PropPage::instance->pwrClash->SetValue(true);
  CHKPRP("BUTTON_LOCKUP") PropPage::instance->pwrLockup->SetValue(true);
  CHKPRP("HOLD_BUTTON_OFF") PropPage::instance->pwrHoldOff->SetValue(true);
  CHKPRP("HOLD_BUTTON_LOCKUP") PropPage::instance->auxHoldLockup->SetValue(true);
  CHKPRP("USE_BC_MELT_STAB") PropPage::instance->meltGestureAlways->SetValue(true);
  CHKPRP("CIRCULAR_VOLUME_MENU") PropPage::instance->volumeCircular->SetValue(true);
  CHKPRP("CIRCULAR_DIM_MENU") PropPage::instance->brightnessCircular->SetValue(true);
  CHKPRP("EDIT") PropPage::instance->editEnable->SetValue(true);
  CHKPRP("EDIT_MODE_MENU") PropPage::instance->editMode->SetValue(true);
  CHKPRP("EDIT_SETTINGS_MENU") PropPage::instance->editSettings->SetValue(true);

  CHKPRP("DISABLE_TALKIE") PropPage::instance->beepErrors->SetValue(true);
  CHKPRP("TRACK_PLAYER_NO_PROMPTS") PropPage::instance->trackPlayerPrompts->SetValue(false);
  CHKPRP("SAY_COLOR_LIST") PropPage::instance->spokenColors->SetValue(true);
  CHKPRP("SAY_BATTERY_VOLTS") PropPage::instance->spokenBatteryVolts->SetValue(true);
  CHKPRP("SAY_BATTERY_PERCENT") PropPage::instance->spokenBatteryPercent->SetValue(true);

  CHKPRP("FETT263_FORCE_PUSH") PropPage::instance->forcePushBM->SetValue(true);
  else CHKPRP("FORCE_PUSH") PropPage::instance->forcePush->SetValue(true);
  CHKPRP("FORCE_PUSH_ALWAYS") PropPage::instance->forcePush->SetValue(true);
  CHKPRP("FORCE_PUSH_LENGTH") PropPage::instance->forcePushLength->num->SetValue(DEFNUM);

  CHKPRP("DISABLE_QUOTE_PLAYER") PropPage::instance->enableQuotePlayer->SetValue(false);
  CHKPRP("RANDOMIZE_QUOTE_PLAYER") PropPage::instance->randomizeQuotePlayer->SetValue(true);
  CHKPRP("QUOTE_PLAYER_START_ON") PropPage::instance->quotePlayerDefault->SetValue(true);

  CHKPRP("SPECIAL_ABILITIES") PropPage::instance->specialAbilities->SetValue(true);
  CHKPRP("MULTI_PHASE") PropPage::instance->multiPhase->SetValue(true);
  CHKPRP("SPIN_MODE") PropPage::instance->spinMode->SetValue(true);
  CHKPRP("SAVE_CHOREOGRAPHY") PropPage::instance->saveChoreo->SetValue(true);
  CHKPRP("SAVE_GESTURE_OFF") PropPage::instance->saveGesture->SetValue(true);
  CHKPRP("DUAL_MODE_SOUND") PropPage::instance->dualModeSound->SetValue(true);
  CHKPRP("QUICK_SELECT_ON_BOOT") PropPage::instance->quickPresetSelect->SetValue(true);
  CHKPRP("DISABLE_MULTI_BLAST_TOGGLE") PropPage::instance->multiBlastDisableToggle->SetValue(true);
  else CHKPRP("DISABLE_MULTI_BLAST") PropPage::instance->multiBlast->SetValue(false);
  CHKPRP("DISABLE_CHANGE_FONT") PropPage::instance->fontChangeOTF->SetValue(false);
  CHKPRP("DISABLE_CHANGE_STYLE") PropPage::instance->styleChangeOTF->SetValue(false);
  CHKPRP("DISABLE_COPY_PRESET") PropPage::instance->presetCopyOTF->SetValue(false);
  CHKPRP("CLASH_STRENGTH_SOUND") PropPage::instance->clashStrengthSound->SetValue(true);
  CHKPRP("MAX_CLASH") PropPage::instance->clashStrengthSoundMaxClash->num->SetValue(DEFNUM);

  CHKPRP("BATTLE_MODE_START_ON") PropPage::instance->battleModeOnStart->SetValue(true);
  CHKPRP("BATTLE_MODE_ALWAYS_ON") PropPage::instance->battleModeAlways->SetValue(true);
  CHKPRP("DISABLE_BM_TOGGLE") PropPage::instance->battleModeNoToggle->SetValue(true);
  CHKPRP("GESTURE_AUTO_BATTLE_MODE") PropPage::instance->gestureEnBattle->SetValue(true);
  CHKPRP("LOCKUP_DELAY") PropPage::instance->lockupDelay->num->SetValue(DEFNUM);
  CHKPRP("BM_CLASH_DETECT") PropPage::instance->battleModeClash->num->SetValue(DEFNUM);
  CHKPRP("BM_DISABLE_OFF_BUTTON") PropPage::instance->battleModeDisablePWR->SetValue(true);

# undef CHKDEF
# undef CHKPRP
# undef DEFVAL
# undef DEFNUM
}
void Configuration::readPresetArray(std::ifstream& file) {
# define CHKSECT if (file.eof() || element == "#endif" || strstr(element.data(), "};") != NULL) return
# define RUNTOSECTION element.clear(); while (element != "{") { file >> element; CHKSECT; }

  BladeIDPage::instance->bladeArrays.push_back(BladeIDPage::BladeArray());
  BladeIDPage::BladeArray& bladeArray = BladeIDPage::instance->bladeArrays.at(BladeIDPage::instance->bladeArrays.size() - 1);

  char* tempData;
  std::string presetInfo;
  std::string element;
  std::string comment;
  element.clear();
  file >> element;
  bladeArray.name.assign(std::strtok(element.data(), "[]"));

  RUNTOSECTION;
  uint32_t preset = -1;
  bladeArray.presets.clear();
  while (!false) {
    presetInfo.clear();
    RUNTOSECTION;
    bladeArray.presets.push_back(PresetsPage::PresetConfig());
    preset++;

    while (std::strstr(presetInfo.data(), "}") == nullptr) {
      file >> element;
      CHKSECT;
      presetInfo.append(element);
    }

    // Directory
    element = presetInfo.substr(0, presetInfo.find(",")); // Get dir section
    presetInfo = presetInfo.substr(presetInfo.find(",") + 1); // increment presetInfo
    tempData = std::strtok(element.data(), ",\""); // Detokenize dir section
    bladeArray.presets[preset].dirs.assign(tempData == nullptr ? "" : tempData);

    // Same thing but for track
    element = presetInfo.substr(0, presetInfo.find(","));
    presetInfo = presetInfo.substr(presetInfo.find(",") + 1);
    tempData = std::strtok(element.data(), ",\"");
    bladeArray.presets[preset].track.assign(tempData == nullptr ? "" : tempData);

    // Deal with Fett's comments
    comment.clear();
    if (presetInfo.find("/*") != std::string::npos) {
      comment = presetInfo.substr(presetInfo.find("/*"), presetInfo.find("*/") + 2);
      presetInfo = presetInfo.substr(presetInfo.find("*/") + 2);
    }

    // Read actual styles
    for (uint32_t blade = 0; blade < numBlades; blade++) {
      if (presetInfo.find("&style_charging,") == 0) {
        presetInfo = presetInfo.substr(16 /* length of "&style_charging,"*/);
        bladeArray.presets[preset].styles.push_back("&style_charging");
      } else if (presetInfo.find("&style_pov") == 0) {
        presetInfo = presetInfo.substr(presetInfo.find(11 /* length of "&style_pov,"*/));
        bladeArray.presets[preset].styles.push_back("&style_pov");
      } else {
        element = presetInfo.substr(0, presetInfo.find("(),") + 2); // Copy in next

        presetInfo = presetInfo.substr(presetInfo.find("(),") + 3); // Increment
        bladeArray.presets[preset].styles.push_back(comment + element.substr(element.find("Style"), element.find("(),")));
      }
    }

    // Name
    tempData = std::strtok(presetInfo.data(), ",\"");
    bladeArray.presets[preset].name.assign(tempData == nullptr ? "" : tempData);
  }
# undef CHKSECT
# undef RUNTOSECTION
}
void Configuration::readBladeArray(std::ifstream& file) {
# define CHKSECT if (file.eof() || element == "#endif" || strstr(element.data(), "};") != NULL) return
# define RUNTOSECTION element.clear(); while (element != "{") { file >> element; CHKSECT; }
  // In future get detect val and presetarray association

  BladeIDPage::BladeArray bladeArray;
  std::string element;
  std::string data;
  uint32_t tempNumBlades;
  RUNTOSECTION;

  while (true) {
    bladeArray = {};
    RUNTOSECTION;
    file >> element;
    element = std::strtok(element.data(), " ,");
    bladeArray.value = std::strstr(element.data(), "NO_BLADE") ? 0 : std::stoi(element);
    CHKSECT;
    bladeArray.blades.clear();
    tempNumBlades = numBlades;
    for (uint32_t blade = 0; blade < tempNumBlades; blade++) {
      data.clear();

      do { // Gather entire blade data
        file >> element;
        CHKSECT;
        data.append(element);
      } while (std::strstr(data.data(), "),") == nullptr);

      if (std::strstr(data.data(), "SubBlade") != nullptr) {
        if (std::strstr(data.data(), "NULL") == nullptr) { // Top Level SubBlade
          bladeArray.blades.push_back(BladesPage::BladeConfig());
          if (std::strstr(data.data(), "WithStride")) bladeArray.blades[blade].subBladeWithStride = true;
        } else { // Lesser SubBlade
          blade--;
          tempNumBlades--;
          // Switch to operating on previous blade
        }

        bladeArray.blades[blade].isSubBlade = true;
        std::strtok(data.data(), "("); // SubBlade(
        bladeArray.blades[blade].subBlades.push_back({ (uint32_t)std::stoi(std::strtok(nullptr, "(,")), (uint32_t)std::stoi(std::strtok(nullptr, " (,")) });
        data = std::strtok(nullptr, ""); // Clear out mangled data from strtok, replace with rest of data ("" runs until end of what's left)
        // Rest will be handled by WS281X "if"
      }
      if (std::strstr(data.data(), "WS281XBladePtr") != nullptr) {
        if (bladeArray.blades.size() - 1 != blade) bladeArray.blades.push_back(BladesPage::BladeConfig());
        data = std::strstr(data.data(), "WS281XBladePtr"); // Shift start to blade data, in case of SubBlade;

        // This must be done first since std::strtok is destructive (adds null chars)
        if (std::strstr(data.data(), "bladePowerPin1") != nullptr) bladeArray.blades[blade].usePowerPin1 = true;
        if (std::strstr(data.data(), "bladePowerPin2") != nullptr) bladeArray.blades[blade].usePowerPin2 = true;
        if (std::strstr(data.data(), "bladePowerPin3") != nullptr) bladeArray.blades[blade].usePowerPin3 = true;
        if (std::strstr(data.data(), "bladePowerPin4") != nullptr) bladeArray.blades[blade].usePowerPin4 = true;
        if (std::strstr(data.data(), "bladePowerPin5") != nullptr) bladeArray.blades[blade].usePowerPin5 = true;
        if (std::strstr(data.data(), "bladePowerPin6") != nullptr) bladeArray.blades[blade].usePowerPin6 = true;

        std::strtok(data.data(), "<,"); // Clear WS281XBladePtr
        bladeArray.blades[blade].numPixels = std::stoi(std::strtok(nullptr, "<,"));
        bladeArray.blades[blade].dataPin = std::strtok(nullptr, ",");
        std::strtok(nullptr, ":"); // Clear Color8::
        element = std::strtok(nullptr, ":,"); // Set to color order;
        bladeArray.blades[blade].useRGBWithWhite = strstr(element.data(), "W") != nullptr;
        bladeArray.blades[blade].colorType.assign(element);

        continue;
      }
      if (std::strstr(data.data(), "SimpleBladePtr") != nullptr) {
        bladeArray.blades.push_back(BladesPage::BladeConfig());
        uint32_t numLEDs = 0;
        auto getStarTemplate = [](const std::string& element) -> std::string {
          if (std::strstr(element.data(), "RedOrange") != nullptr) return "RedOrange";
          if (std::strstr(element.data(), "Amber") != nullptr) return "Amber";
          if (std::strstr(element.data(), "White") != nullptr) return "White";
          if (std::strstr(element.data(), "Red") != nullptr) return "Red";
          if (std::strstr(element.data(), "Green") != nullptr) return "Green";
          if (std::strstr(element.data(), "Blue") != nullptr) return "Blue";
          // With this implementation, RedOrange must be before Red
          return BD_NORESISTANCE;
        };

        // These must be read first since std::strtok is destructive (adds null chars)
        if (std::strstr(data.data(), "bladePowerPin1") != nullptr) bladeArray.blades[blade].usePowerPin1 = true;
        if (std::strstr(data.data(), "bladePowerPin2") != nullptr) bladeArray.blades[blade].usePowerPin2 = true;
        if (std::strstr(data.data(), "bladePowerPin3") != nullptr) bladeArray.blades[blade].usePowerPin3 = true;
        if (std::strstr(data.data(), "bladePowerPin4") != nullptr) bladeArray.blades[blade].usePowerPin4 = true;
        if (std::strstr(data.data(), "bladePowerPin5") != nullptr) bladeArray.blades[blade].usePowerPin5 = true;
        if (std::strstr(data.data(), "bladePowerPin6") != nullptr) bladeArray.blades[blade].usePowerPin6 = true;

        std::strtok(data.data(), "<"); // Clear SimpleBladePtr and setup strtok

        element = std::strtok(nullptr, "<,");
        bladeArray.blades[blade].Star1.assign(getStarTemplate(element));
        if (bladeArray.blades[blade].Star1 != BD_NORESISTANCE) {
          numLEDs++;
          bladeArray.blades[blade].Star1Resistance = std::stoi(std::strtok(nullptr, "<>"));
        }
        element = std::strtok(nullptr, "<,");
        bladeArray.blades[blade].Star2.assign(getStarTemplate(element));
        if (bladeArray.blades[blade].Star2 != BD_NORESISTANCE) {
          numLEDs++;
          bladeArray.blades[blade].Star2Resistance = std::stoi(std::strtok(nullptr, "<>"));
        }
        element = std::strtok(nullptr, "<, ");
        bladeArray.blades[blade].Star3.assign(getStarTemplate(element));
        if (bladeArray.blades[blade].Star3 != BD_NORESISTANCE) {
          numLEDs++;
          bladeArray.blades[blade].Star3Resistance = std::stoi(std::strtok(nullptr, "<>"));
        }
        element = std::strtok(nullptr, "<, ");
        bladeArray.blades[blade].Star4.assign(getStarTemplate(element));
        if (bladeArray.blades[blade].Star4 != BD_NORESISTANCE) {
          numLEDs++;
          bladeArray.blades[blade].Star4Resistance = std::stoi(std::strtok(nullptr, "<>"));
        }

        if (numLEDs <= 2) bladeArray.blades[blade].type.assign(BD_SINGLELED);
        if (numLEDs == 3) bladeArray.blades[blade].type.assign("Tri-Star Star");
        if (numLEDs >= 4) bladeArray.blades[blade].type.assign("Quad-Star Star");
      }
    }

    data.clear();
    do {
      file >> element;
      CHKSECT;
      data.append(element);
    } while (std::strstr(data.data(), ")") == nullptr);

    int32_t nameStart = data.find("CONFIGARRAY(") + 12;
    int32_t nameEnd = data.find(")");
    bladeArray.name.assign(data.substr(nameStart, nameEnd - nameStart));

    if (bladeArray.blades.empty())
      bladeArray.blades.push_back(BladesPage::BladeConfig{});

    for (BladeIDPage::BladeArray& array : BladeIDPage::instance->bladeArrays) {
      if (array.name == bladeArray.name) {
        array.value = bladeArray.value;
        array.blades = bladeArray.blades;
      }
    }
  }

# undef CHKSECT
# undef RUNTOSECTION
}
void Configuration::replaceStyles(const std::string& styleName, const std::string& styleFill) {
  std::string styleCheck;
  for (PresetsPage::PresetConfig& preset : BladeIDPage::instance->bladeArrays[BladesPage::instance->bladeArray->GetSelection()].presets) {
    for (wxString& style : preset.styles) {
      styleCheck = (style.find(styleName) == std::string::npos) ? style : style.substr(style.find(styleName));
      while (styleCheck != style) {
        // If there are no comments in the style, we're fine.
        // if the start of the next comment comes before the end of a comment, we *should* be outside the comment, and we're good to go.
        // This potentially could be broken though...
        if (style.find("/*") == std::string::npos || styleCheck.find("/*") <= styleCheck.find("*/")) {
          style.replace(style.find(styleCheck), styleName.length(), styleFill);
        }
        styleCheck = styleCheck.find(styleName) == std::string::npos ? style : style.substr(styleCheck.find(styleName));
      }
    }
  }
}

bool Configuration::runPrechecks() {
# define ERR(msg) \
  Misc::MessageBoxEvent* msgEvent = new Misc::MessageBoxEvent(Misc::EVT_MSGBOX, wxID_ANY, msg, "Configuration Error"); \
  wxQueueEvent(MainWindow::instance->GetEventHandler(), msgEvent); \
  return false;

  if (BladeIDPage::instance->enableDetect->GetValue() && BladeIDPage::instance->detectPin->entry->GetValue() == "") {
    ERR("Blade Detect Pin cannot be empty.");
  }
  if (BladeIDPage::instance->enableID->GetValue() && BladeIDPage::instance->IDPin->entry->GetValue() == "") {
    ERR("Blade ID Pin cannot be empty.");
  }
  if ([]() { for (const BladeIDPage::BladeArray& array : BladeIDPage::instance->bladeArrays) if (array.name == "") return true; return false; }()) {
    ERR("Blade Array Name cannot be empty.");
  }
  if (BladeIDPage::instance->enableID->GetValue() && BladeIDPage::instance->mode->GetStringSelection() == BLADE_ID_MODE_BRIDGED && BladeIDPage::instance->pullupPin->entry->GetValue() == "") {
    ERR("Pullup Pin cannot be empty.");
  }
  if (BladeIDPage::instance->enableDetect->GetValue() && BladeIDPage::instance->enableID->GetValue() && BladeIDPage::instance->IDPin->entry->GetValue() == BladeIDPage::instance->detectPin->entry->GetValue()) {
    ERR("Blade ID Pin and Blade Detect Pin cannot be the same.");
  }
  if ([]() -> bool {
        auto getNumBlades = [](const BladeIDPage::BladeArray& array) {
          int32_t numBlades = 0;
          for (const BladesPage::BladeConfig& blade : array.blades) {
            blade.isSubBlade ? numBlades += blade.subBlades.size() : numBlades++;
          }
          return numBlades;
        };

        int32_t lastNumBlades = getNumBlades(BladeIDPage::instance->bladeArrays.at(0));
        for (const BladeIDPage::BladeArray& array : BladeIDPage::instance->bladeArrays) {
          if (getNumBlades(array) != lastNumBlades) return true;
          lastNumBlades = getNumBlades(array);
        }
        return false;
      }()) {
    ERR("All Blade Arrays must be the same length.\n\nPlease add/remove blades to make them equal");
  }


  return true;
# undef ERR
}

Configuration::ProffieBoard Configuration::parseBoardType(const std::string& value) {
  return value == "ProffieBoard V1" ? Configuration::ProffieBoard::V1 :
             value == "ProffieBoard V2" ? Configuration::ProffieBoard::V2 :
             Configuration::ProffieBoard::V3;
}
Configuration::SaberProp Configuration::parsePropSel(const std::string& value) {
  return value == PR_SA22C ? Configuration::SaberProp::SA22C :
             value == PR_FETT263 ? Configuration::SaberProp::FETT263 :
             value == PR_BC ? Configuration::SaberProp::BC :
             value == PR_CAIWYN ? Configuration::SaberProp::CAIWYN :
             value == PR_SHTOK ? Configuration::SaberProp::SHTOK :
             Configuration::SaberProp::DEFAULT;
}

