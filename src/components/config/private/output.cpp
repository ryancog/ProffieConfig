#include "io.h"
/*
 * ProffieConfig, All-In-One Proffieboard Management Utility
 * Copyright (C) 2023-2025 Ryan Ogurek
 *
 * components/config/private/output.cpp
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 4 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <fstream>
#include <limits>
#include <sstream>

#include "config/config.h"
#include "config/bladeconfig/ws281x.h"
#include "log/branch.h"
#include "utils/string.h"
#include "utils/version.h"

namespace Config {
    optional<string> runPreChecks(const Config&, Log::Branch&);

    void outputTop(std::ofstream&, const Config&);
    void outputTopGeneral(std::ofstream&, const Config&);
    void outputTopProp(std::ofstream&, const Config&);

    void outputProp(std::ofstream&, const Config&);

    void outputPresets(std::ofstream&, const Config&);
    void outputPresetStyles(std::ofstream&, const Config&);
    void outputPresetBlades(std::ofstream&, const Config&);

    void outputButtons(std::ofstream&, const Config&);

    template<typename VAL = string>
    void outputOpt(std::ofstream&, const string& opt, const VAL& val);
    template<typename VAL = string>
    void outputOpt(std::ofstream&, const string& opt);
    template<typename VAL = string>
    void outputDefine(std::ofstream&, const string& define);
    template<typename VAL = string>
    void outputDefine(std::ofstream&, const string& define, const VAL& val);

} // namespace Config

optional<string> Config::output(const filepath& filePath, const Config& config, Log::Branch *lBranch) {
    auto& logger{Log::Branch::optCreateLogger("Config::output()", lBranch)};

    auto precheckErr{runPreChecks(config, *logger.binfo("Running prechecks..."))};
    if (precheckErr) return precheckErr;

    // if (fullOutput) {
    //     std::error_code err;
    //     const auto injectionDir{Paths::proffieos() / "config" / INJECTION_STR};
    //     for (const auto& injection : editor->presetsPage->injections) {
    //         auto injectionPath{injectionDir / filepath{injection}};
    //         fs::create_directories(injectionPath.parent_path());
    //         if (not fs::copy_file(
    //             Paths::injections() / filepath{injection},
    //             injectionPath,
    //             fs::copy_options::overwrite_existing,
    //             err
    //         )) {
    //             errorMessage(logger, editor, wxTRANSLATE("Failed setting up injection \"%s\""), injection);
    //             return false;
    //         }
    //     }
    // }

    std::ofstream outFile(filePath);
    if (not outFile.is_open()) {
        return errorMessage(logger, wxTRANSLATE("Could not open config file for output."));
    }

    
    outFile << "/*\n";
    outFile << " * This configuration file was generated by ProffieConfig, created by Ryryog25.\n";
    outFile << " * ProffieConfig is an All-In-One utility for managing your Proffieboard.\n";
    outFile << " * https://proffieconfig.kafrenetrading.com/\n";
    outFile << " *\n";
    outFile << " * Version: " wxSTRINGIZE(VERSION) ", Generator Version: " wxSTRINGIZE(BIN_VERSION) "\n";
    outFile << " */\n\n" << std::flush;

    outputTop(outFile, config);
    outputProp(outFile, config);
    outputPresets(outFile, config);
    outputButtons(outFile, config);

    outFile.close();

    logger.info("Done");
    return nullopt;
}

optional<string> Config::runPreChecks(const Config& config, Log::Branch& lBranch) {
    auto& logger{lBranch.createLogger("Config::runPreChecks()")};

    if (config.settings.bladeDetect and static_cast<string>(config.settings.bladeDetectPin) == "") {
        return errorMessage(logger, wxTRANSLATE("Blade Detect Pin cannot be empty."));
    }
    if (config.settings.bladeID.enable) {
        if (static_cast<string>(config.settings.bladeID.pin) == "") {
            return errorMessage(logger, wxTRANSLATE("Blade ID Pin cannot be empty."));
        }
        if (
                config.settings.bladeID.mode == Settings::BladeID::BRIDGED and
                static_cast<string>(config.settings.bladeID.bridgePin) == ""
           ) {
            return errorMessage(logger, wxTRANSLATE("Pullup Pin cannot be empty."));
        }
    }
    if (
            config.settings.bladeDetect and config.settings.bladeID.enable and
            static_cast<string>(config.settings.bladeDetectPin) == static_cast<string>(config.settings.bladeID.pin)
       ) {
        return errorMessage(logger, wxTRANSLATE("Blade ID Pin and Blade Detect Pin cannot be the same."));
    }

    for (const auto& array : config.bladeArrays.arrays()) {
        auto issues{array->computeIssues()};
        if (issues != BladeConfig::ISSUE_NONE) {
            return errorMessage(logger, BladeConfig::issueString(issues));
        }
    }

    for (auto arrayIdx{0}; arrayIdx < config.bladeArrays.arrays().size(); ++arrayIdx) {
        const auto& bladeArray{config.bladeArrays.array(arrayIdx)};
        const auto arrayName{config.bladeArrays.arraySelection.choices()[arrayIdx]};
        if (bladeArray.presetArray == -1) {
            return errorMessage(logger, wxTRANSLATE("Blade array %s has no preset array selection"), arrayName);
        }
        for (auto bladeIdx{0}; bladeIdx < bladeArray.blades().size(); ++bladeIdx) {
            auto& blade{bladeArray.blade(bladeIdx)};

            if (blade.type == Blade::WS281X) {
                if (static_cast<string>(blade.ws281x().dataPin).empty()) {
                    return errorMessage(logger, wxTRANSLATE("Blade %d in array %s missing data pin"), bladeIdx, arrayName);
                }
                // Subblade overlap
            }
            if (blade.type == Blade::SIMPLE) {
                auto& star1{blade.simple().star1};
                auto& star2{blade.simple().star2};
                auto& star3{blade.simple().star3};
                auto& star4{blade.simple().star4};
                constexpr auto SIMPLE_ERR_MSG{wxTRANSLATE("LED %d of blade %d in array %s missing power pin.")};
                if (star1.led != SimpleBlade::Star::NONE and static_cast<string>(star1.powerPin).empty()) {
                    return errorMessage(logger, SIMPLE_ERR_MSG, 1, bladeIdx, arrayName);
                }
                if (star2.led != SimpleBlade::Star::NONE and static_cast<string>(star2.powerPin).empty()) {
                    return errorMessage(logger, SIMPLE_ERR_MSG, 2, bladeIdx, arrayName);
                }
                if (star3.led != SimpleBlade::Star::NONE and static_cast<string>(star3.powerPin).empty()) {
                    return errorMessage(logger, SIMPLE_ERR_MSG, 3, bladeIdx, arrayName);
                }
                if (star4.led != SimpleBlade::Star::NONE and static_cast<string>(star4.powerPin).empty()) {
                    return errorMessage(logger, SIMPLE_ERR_MSG, 4, bladeIdx, arrayName);
                }

                if (
                        star1.led == SimpleBlade::Star::NONE or
                        star1.led == SimpleBlade::Star::NONE or
                        star1.led == SimpleBlade::Star::NONE or
                        star1.led == SimpleBlade::Star::NONE
                   ) {
                    return errorMessage(logger, wxTRANSLATE("Blade %d in array %s has no LEDs"), bladeIdx, arrayName);
                }
            }
        }
    }

    for (const auto& presetArray : config.presetArrays.arrays()) {
        const auto arrayName{static_cast<string>(presetArray->name)};
        if (arrayName.empty()) {
            return errorMessage(logger, wxTRANSLATE("Preset array has no name"));
        }
        for (const auto& checkArray : config.presetArrays.arrays()) {
            if (&checkArray == &presetArray) continue;
            if (static_cast<string>(checkArray->name) == arrayName) {
                return errorMessage(logger, wxTRANSLATE("Duplicate preset arrays %s"), arrayName);
            }
        }
    }

    constexpr cstring STYLE_ERR_STR{wxTRANSLATE("Bladestyle %d in preset %d (%s) in array %s has mismatched %s")};
    for (const auto& presetArray : config.presetArrays.arrays()) {
        for (auto presetIdx{0}; presetIdx < presetArray->presets().size(); ++presetIdx) {
            const auto& preset{presetArray->preset(presetIdx)};
            for (auto styleIdx{0}; styleIdx < preset.styles().size(); ++styleIdx) {
                vector<char> depth;
                for (const char chr : static_cast<string>(preset.style(styleIdx).style)) {
                    if (chr == '<' or chr == '(' or chr == '"') {
                        depth.push_back(chr);
                        continue;
                    }
                    if (chr == '>' or chr == ')' or chr == '"') {
                        if (
                                depth.empty() or 
                                (chr == '>' and depth.back() != '<') or
                                (chr == ')' and depth.back() != '(') or
                                (chr == '"' and depth.back() != '"')
                           ) {
                            return errorMessage(
                                logger, STYLE_ERR_STR, styleIdx, presetIdx,
                                static_cast<string>(preset.name), static_cast<string>(presetArray->name),
                                string{depth.back(), chr}
                            );
                        }
                        depth.pop_back();
                        continue;
                    }
                }
                if (not depth.empty()) {
                    return errorMessage(
                        logger, STYLE_ERR_STR, styleIdx, presetIdx,
                        static_cast<string>(preset.name), static_cast<string>(presetArray->name),
                        string{depth.back()}
                    );
                }
            }
        }
    }

    return nullopt;
}

// bool Config::exportConfig(Config&editor) {
//     wxFileDialog configLocation(editor, _("Save ProffieOS Config File"), "", wxString{editor->getOpenConfig()}, _("ProffieOS Config") + " (*.h)|*.h", wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
// 
//     if (configLocation.ShowModal() == wxID_CANCEL) return false; // User Closed
// 
//     return Config::outputConfig(configLocation.GetPath().ToStdString(), editor);
// }

void Config::outputTop(std::ofstream& outFile, const Config& config) {
    outFile << "#ifdef CONFIG_TOP\n";
    outputTopGeneral(outFile, config);
    outputTopProp(outFile, config);
    outFile << "#endif\n\n" << std::flush;
}

template<typename VAL>
void Config::outputOpt(std::ofstream& outFile, const string& opt) {
    outFile << PC_OPT_STR << opt << '\n';
}

template<typename VAL>
void Config::outputOpt(std::ofstream& outFile, const string& opt, const VAL& val) {
    outFile << PC_OPT_STR << opt << ' ' << val << '\n';
}

template<typename VAL>
void Config::outputDefine(std::ofstream& outFile, const string& define) {
    outFile << DEFINE_STR << define << '\n';
}

template<typename VAL>
void Config::outputDefine(std::ofstream& outFile, const string& define, const VAL& val) {
    outFile << DEFINE_STR << define << ' ' << val << '\n';
}

void Config::outputTopGeneral(std::ofstream& outFile, const Config& config) {
    if (config.settings.massStorage) {
        outputOpt(outFile, Settings::ENABLE_MASS_STORAGE_STR);
    }
    if (config.settings.webUSB) {
        outputOpt(outFile, Settings::ENABLE_WEBUSB_STR);
    }

    Utils::Version osVersion{static_cast<string>(config.settings.osVersion)};
    if (not osVersion.err) outputOpt<string>(outFile, Settings::OS_VERSION_STR, osVersion);
    outFile << INCLUDE_STR << Settings::BOARD_STRS[config.settings.board] << '\n';

    uint32 requiredLedsPerStrip{0};
    for (const auto& array : config.bladeArrays.arrays()) {
        for (const auto& blade : array->blades()) {
            if (blade->type != Blade::WS281X) continue;
            bool whiteMultiplier{blade->ws281x().hasWhite};
            auto length{static_cast<uint32>(blade->ws281x().length)};
            if (whiteMultiplier) {
                length = std::ceil((length * 4.0) / 3.0);
            }
            if (length > requiredLedsPerStrip) requiredLedsPerStrip = length;
        }
    }

    outFile << MAX_LEDS_STR << std::max<uint32>(requiredLedsPerStrip, 144) << '\n';

    if (osVersion.err or osVersion < Utils::Version{"8"}) {
        // No longer needed in OS8 and newer
        outputDefine(outFile, Settings::ENABLE_AUDIO_STR);
        outputDefine(outFile, Settings::ENABLE_MOTION_STR);
        outputDefine(outFile, Settings::ENABLE_WS2811_STR);
        outputDefine(outFile, Settings::ENABLE_SD_STR);
    }

    outputDefine(outFile, Settings::SHARED_POWER_PINS_STR);
    outputDefine(outFile, Settings::NUM_BLADES_STR, config.bladeArrays.numBlades());
    outputDefine<uint32>(outFile, Settings::NUM_BUTTONS_STR, config.settings.numButtons);

    if (config.settings.bladeDetect) {
        outputDefine<string>(outFile, Settings::BLADE_DETECT_PIN_STR, config.settings.bladeDetectPin);
    }

    if (config.settings.bladeID.enable) {
        string idString{Settings::BladeID::MODE_STRS[config.settings.bladeID.mode]};
        idString += config.settings.bladeID.pin;
        if (config.settings.bladeID.mode == Settings::BladeID::EXTERNAL) {
            (idString += ", ") += config.settings.bladeID.pullup;
        } else if (config.settings.bladeID.mode == Settings::BladeID::BRIDGED) {
            (idString += ", ") += config.settings.bladeID.bridgePin;
        }
        idString += ">\n";
        outputDefine(outFile, Settings::BLADE_ID_CLASS_STR, idString);
 
        const auto pinSelect{static_cast<set<uint32>>(config.settings.bladeID.powerPins)};
        if (config.settings.bladeID.powerForID and not pinSelect.empty()) {
            string powerString{POWER_PINS_STR};
            for (auto iter{pinSelect.begin()}; iter != pinSelect.end(); ++iter) {
                powerString += config.settings.bladeID.powerPins.items()[*iter];
                if (std::next(iter) != pinSelect.end()) powerString += ", ";
            }
            powerString += ">\n";
            outputDefine(outFile, Settings::ENABLE_POWER_FOR_ID_STR, powerString);
        }

        if (config.settings.bladeID.continuousScanning) {
            outputDefine(outFile, Settings::BLADE_ID_SCAN_MILLIS_STR, config.settings.bladeID.continuousInterval);
            outputDefine(outFile, Settings::BLADE_ID_TIMES_STR, config.settings.bladeID.continuousTimes);
        }
    }

    outputDefine(outFile, Settings::VOLUME_STR, config.settings.volume);
    if (config.settings.enableBootVolume) {
        outputDefine(outFile, Settings::BOOT_VOLUME_STR, config.settings.bootVolume);
    }
    outputDefine(outFile, Settings::CLASH_THRESHOLD_STR, config.settings.clashThreshold);

    outputDefine(outFile, Settings::PLI_OFF_STR, static_cast<uint32>(std::ceil(config.settings.pliOffTime * 1000)));
    const auto idleOffString{std::to_string(static_cast<uint32>(std::ceil(config.settings.idleOffTime * 60))) + " * 1000"};
    outputDefine(outFile, Settings::IDLE_OFF_STR,  idleOffString);
    const auto motionOffString{std::to_string(static_cast<uint32>(std::ceil(config.settings.motionTimeout * 60))) + " * 1000"};
    outputDefine(outFile, Settings::MOTION_TIMEOUT_STR, motionOffString);

    if (config.settings.disableColorChange) outputDefine(outFile, Settings::DISABLE_COLOR_CHANGE_STR);
    if (config.settings.disableBasicParserStyles) outputDefine(outFile, Settings::DISABLE_BASIC_PARSERS_STR);
    if (config.settings.disableDiagnosticCommands) outputDefine(outFile, Settings::DISABLE_DIAG_COMMANDS_STR);
    if (config.settings.enableDeveloperCommands) outputDefine(outFile, Settings::ENABLE_DEV_COMMANDS_STR);

    if (config.settings.saveState) outputDefine(outFile, Settings::SAVE_STATE_STR);
    if (config.settings.enableAllEditOptions) outputDefine(outFile, Settings::ENABLE_ALL_EDIT_OPTIONS_STR);

    if (config.settings.saveVolume and config.settings.saveVolume.isEnabled()) {
        outputDefine(outFile, Settings::SAVE_VOLUME_STR);
    }
    if (config.settings.savePreset and config.settings.savePreset.isEnabled()) {
        outputDefine(outFile, Settings::SAVE_PRESET_STR);
    }
    if (config.settings.saveColorChange and config.settings.saveColorChange.isEnabled()) {
        outputDefine(outFile, Settings::SAVE_COLOR_STR);
    }

    if (config.settings.enableOLED) outputDefine(outFile, Settings::ENABLE_OLED_STR);

    if (config.settings.orientation != Settings::ORIENTATION_NORMAL) {
        outputDefine(outFile, Settings::ORIENTATION_STR, Settings::ORIENTATION_STRS[config.settings.orientation]);
    }

    if (
            config.settings.orientationRotation.x != 0 or
            config.settings.orientationRotation.y != 0 or
            config.settings.orientationRotation.z != 0
       ) {
        string rotationStr;
        rotationStr += std::to_string(config.settings.orientationRotation.x);
        rotationStr += ", ";
        rotationStr += std::to_string(config.settings.orientationRotation.y);
        rotationStr += ", ";
        rotationStr += std::to_string(config.settings.orientationRotation.z);
        outputDefine(outFile, Settings::ORIENTATION_ROTATION_STR, rotationStr);
    }

    if (config.settings.speakTouchValues) outputDefine(outFile, Settings::SPEAK_TOUCH_VALUES_STR);

    if (config.settings.dynamicBladeDimming and config.settings.dynamicBladeLength.isEnabled()) {
        outputDefine(outFile, Settings::DYNAMIC_BLADE_DIMMING_STR);
    }
    if (config.settings.dynamicBladeLength and config.settings.dynamicBladeLength.isEnabled()) {
        outputDefine(outFile, Settings::DYNAMIC_BLADE_LENGTH_STR);
    }
    if (config.settings.dynamicClashThreshold and config.settings.dynamicClashThreshold.isEnabled()) {
        outputDefine(outFile, Settings::DYNAMIC_CLASH_THRESHOLD_STR);
    }

    if (config.settings.saveBladeDimming and config.settings.saveBladeDimming.isEnabled()) {
        outputDefine(outFile, Settings::SAVE_BLADE_DIM_STR);
    }
    if (config.settings.saveClashThreshold and config.settings.saveClashThreshold.isEnabled()) {
        outputDefine(outFile, Settings::SAVE_CLASH_THRESHOLD_STR);
    }

    if (config.settings.enableFiltering) {
        outputDefine<uint32>(outFile, Settings::FILTER_CUTOFF_STR, config.settings.filterCutoff);
        outputDefine<uint32>(outFile, Settings::FILTER_ORDER_STR, config.settings.filterOrder);
    }

    if (config.settings.audioClashSuppressionLevel != 10) {
        outputDefine<uint32>(outFile, Settings::AUDIO_CLASH_SUPPRESSION_STR, config.settings.audioClashSuppressionLevel);
    }

    if (config.settings.dontUseGyroForClash) outputDefine(outFile, Settings::DONT_USE_GYRO_FOR_CLASH_STR);

    if (config.settings.femaleTalkie) outputDefine(outFile, Settings::FEMALE_TALKIE_STR);
    if (config.settings.disableTalkie) outputDefine(outFile, Settings::DISABLE_TALKIE_STR);

    if (osVersion < Utils::Version{"8"}) {
        // Default on newer version
        if (config.settings.killOldPlayers) outputDefine(outFile, Settings::KILL_OLD_PLAYERS_STR);
        if (config.settings.noRepeatRandom) outputDefine(outFile, Settings::NO_REPEAT_RANDOM_STR);
    }

    for (const auto& customOpt : config.settings.customOptions()) {
        if (static_cast<string>(customOpt->define).empty()) continue;

        const auto valueStr{static_cast<string>(customOpt->value)};
        outputDefine(outFile, customOpt->define, valueStr.empty() ? "" : ' ' + valueStr);
    }
}

void Config::outputTopProp(std::ofstream& outFile, const Config& config) {
    if (config.propSelection == -1) return;
    auto& selectedProp{config.prop(config.propSelection)};

    for (const auto& settingVariant : selectedProp.settings()) {
        Versions::PropSetting *setting;
        if ((setting = std::get_if<Versions::PropToggle>(&*settingVariant)));
        else if ((setting = std::get_if<Versions::PropNumeric>(&*settingVariant)));
        else if ((setting = std::get_if<Versions::PropDecimal>(&*settingVariant)));
        else if (auto *ptr = std::get_if<Versions::PropOption>(&*settingVariant)) {
            setting = &*ptr->selections()[static_cast<uint32>(ptr->selection)];
        }

        auto output{setting->generateDefineString()};
        if (not output) continue;
        outFile << DEFINE_STR << *output << '\n';
    }
    outFile << std::flush;
}

void Config::outputProp(std::ofstream& outFile, const Config& config) {
    if (config.propSelection == -1) return;
    auto& selectedProp{config.prop(config.propSelection)};

    outFile << "#ifdef CONFIG_PROP\n";
    outFile << "#include \"../props/" << selectedProp.filename << "\"\n";
    outFile << "#endif\n" << std::flush;
}

void Config::outputPresets(std::ofstream& outFile, const Config& config) {
    outFile << "#ifdef CONFIG_PRESETS\n";
    for (const auto& injection : config.presetArrays.injections()) {
        outFile << "#include \"" << INJECTION_STR.data() << '/' << injection << "\"\n";
    }
    if (not config.presetArrays.injections().empty()) outFile << '\n';
    outputPresetStyles(outFile, config);
    outputPresetBlades(outFile, config);
    outFile << "#endif\n\n" << std::flush;
}

void Config::outputPresetStyles(std::ofstream& outFile, const Config& config) {
    const auto numBlades{config.bladeArrays.numBlades()};

    for (const auto& presetArray : config.presetArrays.arrays()) {
        outFile << "Preset " << static_cast<string>(presetArray->name) << "[] = {\n";
        for (const auto& preset : presetArray->presets()) {
            outFile << "\t{ \"" << static_cast<string>(preset->fontDir) << "\", \""
                << static_cast<string>(preset->track) << "\",\n";

            for (auto idx{0}; idx < numBlades; ++idx) {
                auto& style{preset->style(idx)};
                string line;

                auto commentStr{static_cast<string>(style.comment)};
                Utils::trimSurroundingWhitespace(commentStr);
                if (not commentStr.empty()) {
                    std::istringstream commentStream{commentStr};
                    outFile << "\t\t/*\n";
                    while (not false) {
                        std::getline(commentStream, line);
                        outFile << "\t\t * " << line << '\n';
                        if (commentStream.eof()) break;
                    }
                    outFile << "\t\t */\n";
                }

                auto styleStr{static_cast<string>(style.style)};
                Utils::trimWhiteSpace(styleStr);
                outFile << "\t\t" << styleStr << ",\n";
            }

            outFile << "\t\t\"" << static_cast<string>(preset->name) << "\"\n\t},\n";
        }
        outFile << "};\n";
    }
}

void Config::outputPresetBlades(std::ofstream& outFile, const Config& config) {
    outFile << "BladeConfig blades[] = {\n";
    for (const auto& bladeArray : config.bladeArrays.arrays()) {
        const auto id{
            bladeArray->id == NO_BLADE ? "NO_BLADE" : std::to_string(bladeArray->id)
        };
        outFile << "\t{ " << id << ",\n";
        for (const auto& blade : bladeArray->blades()) {
            if (blade->type == Blade::UNASSIGNED) {
                outFile << "\t\tSimpleBladePtr<NoLED, NoLED, NoLED, NoLED, -1, -1, -1, -1>(),\n";
                continue;
            }

            std::stringstream bladeStr;
            if (blade->brightness != 100) bladeStr << "DimBlade(" << blade->brightness << ", ";

            if (blade->type == Blade::WS281X) {
                const auto& ws281x{blade->ws281x()};
                bladeStr << "WS281XBladePtr<" << ws281x.length << ", " << static_cast<string>(ws281x.dataPin);
                bladeStr << ", Color8::";
                if (ws281x.hasWhite) {
                    bool whiteFirst{
                        ws281x.colorOrder4 >= WS281XBlade::ORDER4_WFIRST_START and
                        ws281x.colorOrder4 <= WS281XBlade::ORDER4_WFIRST_END
                    };
                    if (whiteFirst) {
                        if (ws281x.useRGBWithWhite) bladeStr << 'W';
                        else bladeStr << 'w';
                        auto strIdx{ws281x.colorOrder4 - WS281XBlade::ORDER4_WFIRST_START};
                        bladeStr << WS281XBlade::ORDER_STRS[strIdx];
                    } else {
                        bladeStr << WS281XBlade::ORDER_STRS[ws281x.colorOrder4];
                        if (ws281x.useRGBWithWhite) bladeStr << 'W';
                        else bladeStr << 'w';
                    }
                } else {
                    bladeStr << WS281XBlade::ORDER_STRS[ws281x.colorOrder3];
                }
                bladeStr << ", " << POWER_PINS_STR;
                const auto selPowerPins{static_cast<set<uint32>>(ws281x.powerPins)};
                for (auto iter{selPowerPins.begin()}; iter != selPowerPins.end(); ++iter) {
                    bladeStr << ws281x.powerPins.items()[*iter];
                    if (std::next(iter) != selPowerPins.end()) bladeStr << ", ";
                }
                bladeStr << ">>()";
            } else if (blade->type == Blade::SIMPLE) {
                const auto& simple{blade->simple()};
                bladeStr << "SimpleBladePtr<";

                auto outputStar{[&bladeStr](const SimpleBlade::Star& star) {
                    bladeStr << SimpleBlade::Star::LED_STRS[star.led];
                    if (star.resistance.isEnabled()) bladeStr << star.resistance << '>';
                    bladeStr << ", ";
                }};
                outputStar(simple.star1);
                outputStar(simple.star2);
                outputStar(simple.star3);
                outputStar(simple.star4);

                auto outputStarPower{[&bladeStr](const SimpleBlade::Star& star) {
                    if (star.powerPin.isEnabled()) bladeStr << static_cast<string>(star.powerPin);
                    else bladeStr << "-1";
                }};
                outputStarPower(simple.star1);
                bladeStr << ", ";
                outputStarPower(simple.star2);
                bladeStr << ", ";
                outputStarPower(simple.star3);
                bladeStr << ", ";
                outputStarPower(simple.star4);

                bladeStr << ">()";
            }

            if (blade->brightness != 100) bladeStr << ')';

            if (
                    blade->type == Blade::SIMPLE or 
                    (blade->type == Blade::WS281X and blade->ws281x().splits().empty())
               ) {
                outFile << "\t\t" << bladeStr.str() << ",\n";
                continue;
            }

            for (const auto& split : blade->ws281x().splits()) {
                if (
                        split->type == Split::STANDARD or
                        split->type == Split::REVERSE or
                        split->type == Split::LIST
                   ) {
                    outFile << "\t\t";
                    if (split->brightness != 100) outFile << "DimBlade(" << split->brightness << ", ";

                    if (split->type == Split::STANDARD) {
                        outFile << "SubBlade(" << split->start << ", " << split->end << ", ";
                    } else if (split->type == Split::REVERSE) {
                        outFile << "SubBladeReverse(" << split->start << ", " << split->end << ", ";
                    } else if (split->type == Split::LIST) {
                        auto listStr{static_cast<string>(split->list)};
                        if (listStr.back() == ',') listStr.pop_back();
                        outFile << "SubBladeWithList<" << listStr << ">(";
                    }

                    if (&*split == &*blade->ws281x().splits().front()) {
                        outFile << bladeStr.str() << ')';                    
                    } else outFile << "nullptr)";

                    if (split->brightness != 100) outFile << ')';
                    outFile << ",\n";
                }

                if (split->type == Split::STRIDE or split->type == Split::ZIG_ZAG) {
                    for (auto idx{0}; idx < split->segments; ++idx) {
                        outFile << "\t\t";
                        // TODO: DimBlade

                        if (split->type == Split::STRIDE) {
                            outFile << "SubBladeWithStride(";
                            outFile << split->start + idx << ", ";
                            outFile << split->end - (split->segments - idx - 1) << ", ";
                            outFile << split->segments << ", ";
                        } else if (split->type == Split::ZIG_ZAG) {
                            outFile << "SubBladeZZ(";
                            outFile << split->start << ", " << split->end << ", ";
                            outFile << split->segments << ", " << idx << ", ";
                        }

                        if (idx == 0 and &*split == &*blade->ws281x().splits().front()) {
                            outFile << bladeStr.str() << ')';                    
                        } else outFile << "nullptr)";

                        // TODO: DimBlade
                        outFile << ",\n";
                    }
                }
            }
        }

        const auto presetArray{
            static_cast<string>(config.presetArrays.arrays()[bladeArray->presetArray]->name)
        };
        outFile << "\t\tCONFIGARRAY(" << presetArray << ")";
        if (not bladeArray->name.empty()) outFile << ", \"" << static_cast<string>(bladeArray->name) << '\"';
        outFile << "\n\t},\n";
    }
    outFile << "};\n" << std::flush;
}

void Config::outputButtons(std::ofstream& outFile, const Config& config) {
    outFile << "#ifdef CONFIG_BUTTONS\n";
    if (config.settings.numButtons >= 1) {
        outFile << "Button PowerButton(BUTTON_POWER, powerButtonPin, \"pow\");\n";
    }
    if (config.settings.numButtons >= 2) {
        outFile << "Button AuxButton(BUTTON_AUX, auxPin, \"aux\");\n";
    }
    if (config.settings.numButtons >= 3) {
        outFile << "Button Aux2Button(BUTTON_AUX2, aux2Pin, \"aux2\");\n";
    }
    outFile << "#endif\n" << std::flush;
}



